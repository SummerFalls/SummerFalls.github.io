{"pages":[{"title":"404 Not Found 该页面不存在","text":"很抱歉，您所访问的地址并不存在。","link":"/404.html"},{"title":"关于我 About Me","text":"职业: 嵌入式软件工程师 邮箱: ro7enkranz@qq.com QQ: 867754977 WeChat: California_37 PSN ID: Ro7enkranz 星座: 天蝎座 语言: C/C++/Java/HTML/CSS IDE: VS Code, VS 2019, Keil MDK, TrueStudio, S32 Design Studio, MCUXpresso IDE, CodeWarrior, DAVE 4, Code Composer Studio, Vivado Design Suite HLx EDA: Altium Designer, EasyEDA 兴趣: 开源硬件, 开源软件, HiFi, 美食, 音乐 游戏平台: Play Station 4, Nintendo Switch 运动: 游泳, 骑行(未来计划…) 正在学习中的: Altium Designer, TouchGFX 开源项目: Microchip_CryptoAuthLib_STM32","link":"/about/index.html"},{"title":"链接 Links","text":"友链 Embedded Development 嵌入式开发 吴川斌: https://www.mr-wu.cn 芯跳不止: http://www.mazirong.com strongerHuang: https://www.strongerhuang.com 焦迪 Nemo: http://jiaodi.tech Muse Lab: https://www.muselab-tech.com 屋脊雀: http://www.wujique.com Front-end &amp; Back-end Development 前后端开发Front-end 前端 Icarus: https://blog.zhangruipeng.me/hexo-theme-icarus Liu Chao: https://lc-soft.io 子弈: http://www.ziyi2.cn zoomdong: http://zoomdong.cn Jrain: https://jrainlau.github.io 这砖烫手: http://blog.lollipop.work leekiwi: https://leekiwi.github.io 令狐洋葱: http://shuaizhang.top Back-end 后端 hangz007: https://hangz007.gitee.io (https://codingshenzx.cn/) 码酱 Waldeinsamkeit: http://luokangyuan.com Other 其它 Akkuman: http://o0o.pub 工具站PCB SnapEDA: https://www.snapeda.com/altium-libraries Datasheets: https://www.datasheets.com/zh-cn ALLDATASHEET: https://www.alldatasheetcn.com 半导小芯: https://www.semiee.com Ultra Librarian: https://www.ultralibrarian.com 3D CONTENTCENTRAL: https://www.3dcontentcentral.cn Engineering Design Utilities: http://sim.okawa-denshi.jp/en Hackaday: https://hackaday.io/projects Code 代码规范命名查找 CodeLF: https://unbug.github.io/codelf aiXcoder 编程辅助程序: https://www.aixcoder.com Navigation ToolFK: https://www.toolfk.com 创造狮导航: http://chuangzaoshi.com Markdown Markdown Nice: https://mdnice.com Markdown Plus: http://mdp.tylingsoft.com Design 大中社: https://www.bigzhong.com Remix Icon: https://remixicon.com FontBase: https://fontba.se 取色器: https://colorpicker.crea-th.at Server 海底光缆地图: https://www.submarinecablemap.com 开放端口检测: https://www.yougetsignal.com/tools/open-ports ping.pe: http://ping.pe 服务器跑分: https://bench.sh Others Hexo: https://hexo.io 打印纸网格制作: http://www.gridzzly.com ASCII Art Generator: http://patorjk.com Remix 3D: https://www.remix3d.com/discover 数字移民: https://blog.shuziyimin.org 趣站 海の見える駅: https://seaside-station.com RTINGS.com: https://www.rtings.com","link":"/links/index.html"},{"title":"文章清单 Article List","text":"1. C优化 ARM C语言编程优化策略（KEIL平台） MDK优化掉不调用的函数和防止没有显式调用的函数被优化掉 简单的C语言结构体实现面向对象的方法 无MMU实现动态加载 单片机高阶技能之动态链接库技术实现的讨论 2. C++ 3. STM321. emWin (μC/GUI, STemWin) 基于 FMC8080接口 8位 LCD的 STemWin的移植 emWin应用之SSD1306使用emWin内部驱动GUIDRV_SPage2. TouchGFX TouchGFX 专题 3. STM32CubeMX 【strongerhuang】 STM32CubeMX系列教程 【Waveshare 微雪】 STM32CubeMX系列教程 4. 电机控制 STMicroelectronics X-CUBE-MCSDK 【电机矢量控制】六步法驱动BLDC电机，使用硬件COM事件，STM32+CUBEMX(HAL库)配置(注：文章存在勘误，已向作者提出，但文中可能还未修正，请注意。2019-9-23) 【电机矢量控制】STM32使用TIM触发ADC，CUBEMX配置(用于电机控制电流采样) 【电机矢量控制】BLDC方波电流环PID整定方案 【电机矢量控制】FOC的敲门砖—SVPWM的三相正弦波电流采样 无刷直流电机（带霍尔BLDC）—简单入门（带STM32实例） STM32 BLDC Control with HALL Sensor 关于STM32定时器中TI1FP1 与TI1FP2及相关话题 5. 外设 当STM32遇到SDRAM STM32F429上SDRAM的应用 STM32F429的程序加载到SDRAM的运行方法 最好的按键扫描和消抖方法，适用于复合、长按、按下或抬起响应按键 STM32 PWM 输入捕获，计算占空比和频率时，捕获的值都必须加1，千万注意。 使用 STM32 测量频率和占空比的几种方法 ST官方基于STM32Cube库的Timer捕获应用 STM32之串口DMA接收不定长数据 STM32 之九 HAL 库串口（USART/UART）驱动 BUG 及解决方法 STM32使用HAL库实现RS485通讯（全双工串口） 6. IAP、FOTA STM32 IAP 在线升级详解 一步一步实现STM32-FOTA系列教程之BIN文件解包C语言实现 STM32中OTA与App使用的问题 基于STM32F429的IAP升级(HAL库/RS485) 7. 网络通讯 在GPRS模块（SIM800C）和STM32芯片上实现MQTT协议（HAL版） pahoMQTT+SIM800C+STM32 移植和使用 STM32与SIM800连接百度物接入MQTT服务器教程 8. 其它 STM32F103+FFT+OLED的音乐频谱制作 4. FreeRTOS 5. μC/OS-II, μC/OS-III 6. 加密 ATSHA204A加密芯片攻略——配置篇 ATSHA204A加密芯片攻略——使用篇 加密芯片ATSHA204读序列号（Serial Number） STM32L071CBTX操作ECC508 硬件加密钱包使用ATECC608A示例(微小的库实现) 7. Windows DLL 注入到指定进程","link":"/list/index.html"}],"posts":[{"title":"C 源文件模板","text":"Eclipse 系 IDE 自动化1. Eclipse 系 IDE 新建.c文件和.h文件时自动添加头部Comments Window -&gt; Preference -&gt; C/C++ -&gt; Code Style -&gt; Code Templates -&gt; Comments -&gt; Files 1234567891011121314151617181920212223/* * _____ ___ ___ ___ ___ ___ ___ * / /::\\ / /\\ / /\\ / /\\ /__/\\ ___ / /\\ /__/| * / /:/\\:\\ / /::\\ / /:/_ / /::\\ \\ \\:\\ / /\\ / /:/_ | |:| * / /:/ \\:\\ / /:/\\:\\ / /:/ /\\ / /:/\\:\\ \\ \\:\\ / /:/ / /:/ /\\ | |:| * /__/:/ \\__\\:| / /:/ \\:\\ / /:/ /::\\ / /:/ \\:\\ _____\\__\\:\\ / /:/ / /:/ /:/_ __| |:| * \\ \\:\\ / /:/ /__/:/ \\__\\:\\ /__/:/ /:/\\:\\ /__/:/ \\__\\:\\ /__/::::::::\\ / /::\\ /__/:/ /:/ /\\ /__/\\_|:|____ * \\ \\:\\ /:/ \\ \\:\\ / /:/ \\ \\:\\/:/~/:/ \\ \\:\\ / /:/ \\ \\:\\~~\\~~\\/ /__/:/\\:\\ \\ \\:\\/:/ /:/ \\ \\:\\/:::::/ * \\ \\:\\/:/ \\ \\:\\ /:/ \\ \\::/ /:/ \\ \\:\\ /:/ \\ \\:\\ ~~~ \\__\\/ \\:\\ \\ \\::/ /:/ \\ \\::/~~~~ * \\ \\::/ \\ \\:\\/:/ \\__\\/ /:/ \\ \\:\\/:/ \\ \\:\\ \\ \\:\\ \\ \\:\\/:/ \\ \\:\\ * \\__\\/ \\ \\::/ /__/:/ \\ \\::/ \\ \\:\\ \\__\\/ \\ \\::/ \\ \\:\\ * \\__\\/ \\__\\/ \\__\\/ \\__\\/ \\__\\/ \\__\\/ * * * @ 名称: ${file_name} * @ 描述: * @ 作者: ${user} * @ 日期: ${date} * @ 版本: V1.0 * @ 历史: V1.0 ${date} Summary * * Copyright (c) 2019 DosonTek Electronics Co., Ltd. All rights reserved. */ 2. Eclipse 系 IDE 新建.c文件时自动添加默认模板函数 Window -&gt; Preference -&gt; C/C++ -&gt; Code Style -&gt; Code Templates -&gt; Files -&gt; C Source File -&gt; Default C Source Template 12345678910111213141516${filecomment}${includes}#include \"${file_base}.h\"${declarations}/******************************************************************************** @name : ${file_base}_Init* @brief :* @param : void* @retval : void*******************************************************************************/void ${file_base}_Init(void){ /* TODO: enter the block content here */} 3. Eclipse 系 IDE 新建.h文件时自动添加默认模板函数声明 Window -&gt; Preference -&gt; C/C++ -&gt; Code Style -&gt; Code Templates -&gt; Files -&gt; C Header File -&gt; Default C Header Template 1234567891011${filecomment}#ifndef ${include_guard_symbol}#define ${include_guard_symbol}${includes}${declarations}void ${file_base}_Init(void);#endif /* ${include_guard_symbol} */","link":"/2019-09-20-C-源文件模板.html"},{"title":"CCSv9 Static Lib 静态库封装及使用","text":"1. 创建工程 注意：默认已将 controlSUITE 安装在 &quot;C:\\ti\\&quot; 目录下。 Code Composer Studio Version: 9.0.1.00004 通过 Project -&gt; New CCS Project 分别创建两个工程： 工程1 - 应用工程 Target: TMS320F28027 Connection: Texas Instruments XDS100v3 USB Debug Probe Project Name: A_F28027_TestCase Tool-chain: Output type: Executable Output format: legacy COFF Linker command file: 1C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_common\\cmd\\F28027.cmd Runtime support library: &lt;automatic&gt; Project templates and examples: Empty Project (with main.c) 工程2 - 静态库工程 Target: TMS320F28027 Connection: Texas Instruments XDS100v3 USB Debug Probe Project Name: A_F28027_TestCase_Lib Tool-chain: Output type: Static Library Output format: legacy COFF Project templates and examples: Empty Project 2. 工程设置工程1 - 应用工程 添加 Linker File(*.cmd) 如下图所示，将以下目录下的链接文件 F2802x_Headers_nonBIOS.cmd 拖动到工程目录下，此时弹出对话框 File Operation，选择 Link to files，之后下拉列表框内选择 TI_PRODUCTS_DIR，接着单击 OK 即可。该链接文件用于将外设寄存器映射到正确的内存地址。 1C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_headers\\cmd 添加 controlSUITE 库源文件(*.asm, *.c) 分别将以下目录下的文件添加到工程当中(相对路径添加法)。 12C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_common\\source\\C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_headers\\source\\ 1. 具体步骤右键单击工程名 -&gt; New -&gt; Folder： 选择本工程: A_F28027_TestCase Folder name: F2802x_Common 单击 Advanced 选择 Link to alternate location (Linked Folder) 方法一：编辑框直接输入以下地址 1TI_PRODUCTS_DIR/controlSUITE/device_support/f2802x/v230/f2802x_common/source 方法二：Variables -&gt; TI_PRODUCTS_DIR -&gt; Extend -&gt; controlSUITE -&gt; device_support -&gt; f2802x -&gt; v230 -&gt; f2802x_common -&gt; source -&gt; OK Finish 2. 以同样方法添加其余目录下的源文件1TI_PRODUCTS_DIR/controlSUITE/device_support/f2802x/v230/f2802x_headers/source 添加 controlSUITE 库头文件(*.h) Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Compiler -&gt; Include Options -&gt; Add dir to #include search path(–include_path, -I) 1234${PROJECT_ROOT}${CG_TOOL_ROOT}/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v230/f2802x_common/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v230/f2802x_headers/include 添加全局宏 Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Compiler -&gt; Predefined Symbols -&gt; Pre-define NAME(–define, -D) _DEBUG LARGE_MODEL FLASH DEBUG 编译后的错误(Error)解决1. 编译后报很多重名错误，类似如下 symbol &quot;_DSP28x_DisableInt&quot; redefined: first defined in &quot;./F2802x_Common/f2802x_asmfuncs.obj&quot;; redefined in &quot;./F2802x_Common/f2802x_disint.obj&quot; 解决方法： 右键单击对应源文件 -&gt; Exclude from Build 123456789101112131415/* A. 如下源文件二组择一组排除编译 *//* Exclude 如下2个文件 */f2802x_swprioritizeddefaultisr.cf2802x_swprioritizedpievect.c/* 或如下2个文件 */f2802x_defaultisr.cf2802x_pievect.c/* B. 如下源文件二组择一组排除编译 *//* Exclude 如下1个文件 */f2802x_asmfuncs.asm/* 或如下3个文件 */f2802x_usdelay.asmf2802x_dbgier.asmf2802x_disint.asm 编译后的报警(Warning)解决1. #10210-D null: creating “.esysmem” section with default size of 0x400; use the -heap option to change the default size 解决方法： Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Linker -&gt; Basic Options: Heap size for C/C++ dynamic memory allocation (–heap_size, -heap) = 0x400 3. 创建源文件通过 New -&gt; Header File 或 Source File 分别创建头文件和源文件 Step 1. 工程2 - 静态库工程 创建 LIB_MathFuncs.h 和 LIB_MathFuncs.c LIB_MathFuncs.h12345678#ifndef LIB_MATHFUNCS_H_#define LIB_MATHFUNCS_H_#include &lt;stdint.h&gt;uint32_t LIB_Math_Add(uint32_t x, uint32_t y);#endif /* LIB_MATHFUNCS_H_ */ LIB_MathFuncs.c123456789101112#include \"LIB_MathFuncs.h\"/******************************************************************************** @name : LIB_Math_Add* @brief : 创建一个加法函数，仅做演示。* @param : uint32_t x, uint32_t y* @retval : uint32_t*******************************************************************************/uint32_t LIB_Math_Add(uint32_t x, uint32_t y){ return (x + y);} 编译静态库工程 编译之后即可发现本工程的 Debug 目录下生成了 A_F28027_TestCase_Lib.lib 库文件。 Step 2. 工程1 - 应用工程 复制库文件 将 A_F28027_TestCase_Lib.lib 和 LIB_MathFuncs.h 复制到应用工程下，如图： 添加 A_F28027_TestCase_Lib 库头文件(*.h) Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Compiler -&gt; Include Options -&gt; Add dir to #include search path(–include_path, -I) 1${PROJECT_ROOT}/DTek_LIB 添加 A_F28027_TestCase_Lib 库引用(*.lib) Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Linker -&gt; File Search Path -&gt; Include library file or command file as input (–library, -l) 1${PROJECT_ROOT}/DTek_LIB/A_F28027_TestCase_Lib.lib 创建 main.h 和 main.c main.h1234#ifndef MAIN_H_#define MAIN_H_#endif /* MAIN_H_ */ main.c1234567891011121314151617181920212223#include \"main.h\"#include \"DSP28x_Project.h\"#include \"LIB_MathFuncs.h\"volatile uint32_t resultVal = 0U;/******************************************************************************** @name : main* @brief :* @param : void* @retval : int*******************************************************************************/int main(void){ resultVal = LIB_Math_Add(0, 1); while (resultVal) { /* TODO: Do something here... */ } return 0;} 4. 调试进入调试模式验证 静态库 函数是否能够被正常调用并执行","link":"/2019-09-24-CCSv9-Static-Lib-静态库封装及使用.html"},{"title":"C语言开发标准（微控制器）","text":"C语言开发标准（微控制器）Ver 1.0.0 Written By Tomy Stark.E-mail: ro7enkranz@qq.com Note: 该标准仅限微控制器平台（RTOS or Bare Metal），不完全适合Linux程序的开发标准。 本标准会不定期迭代完善 嵌入式开发中，务必注意不同硬件体系架构之间数据类型的差异： 12345678910111213141516171819/* 为保证健壮性和可移植性，一般情况下，一律使用以下类型来定义变量 *//* 无符号型 */uint8_tuint16_tuint32_t/* 有符号型 */int8_tint16_tint32_t/* 而不使用（尽量少用）以下类型来定义变量 *//* 无符号型 */unsigned charunsigned shortunsigned int/* 有符号型 */signed charsigned shortsigned int 关于注释： 针对代码的注释，采用单行注释： 1// 或多行注释（当需要注释的代码量较多时）： 123#if 0#endif 针对对某些功能、注意事项、函数等的描述性文字，采用多行注释： 12345678/* comment */或在内容较多需要换行时：/*当前时钟频率: SYSCLK = HCLK = PCLK2(APB2) = 96 MHz因为 TIM_ClockDivision = TIM_CKD_DIV1，所以 CLK_Freq 为 PCLK2 的一分频，所以 CLK_Freq = 96 MHz*/ 关于缩进：一律采用“空格”缩进，缩进 4 个空格。 宏函数和内联函数，一般情况下不建议使用宏函数，而更建议使用内联函数，易于调试同时兼具性能。同时，在使用内联函数时需要注意函数体不能太过庞大复杂，否则仍旧会被编译器作为普通函数处理，例如，当对另一个函数进行别名封装时，可以使用内联函数： 1234static inline status_t PINS_DRV_Deinit(uint32_t pinCount, const pin_settings_config_t config[]){ return PINS_DRV_Init(pinCount, config);} 针对“宏”的一些操作需要确保正确，因为宏不易调试，正常情况下，应以让代码更易于阅读和维护，同时又兼顾性能的原则来使用宏，因为花了很多时间想出来的“高效又高深的宏”同样可能需要让别人甚至自己花很多时间去理解，这样无形之中就增加了软件维护成本，特别在项目交接或者不同项目之间代码复用时，矛盾尤为突出，故编程时应在高大上和可维护性之间找到一个平衡点，做出合适的取舍。 对于规律性的常量型定义，例如有相关性的从n开始递增的多个常量数据定义，建议使用enum枚举型而尽量不用宏定义，因为宏定义不易于调试，而枚举类型易于调试。 尽量不要在条件判断语句中使用赋值语句，例如 1234if (a = b){ return true;} 如果有意为之，务必加上注释进行必要说明，明确此写法用意。 合理结合使用“联合体 union”和“结构体 struct”和“位域”，对于特定情形下，可以精简代码量，减少内存占用，提高代码可重用性。例如基于某个通讯外设（I2C、SPI……）上发送的数据帧，包含不同类型的数据情况下，可用此法，但是必须注意字节对齐问题。 同样是 字节对齐问题，为了保证字节对齐，同时更节省内存空间，提高MCU执行效率（缩短程序执行时间），结构体中的数据类型请按从小到大的顺序依次排列 (8位-&gt;16位-&gt;32位-&gt;单精度浮点-&gt;双精度浮点)。例如以下代码片段： 1234567typedef struct { uint8_t DMA_TC_Flag; /* DMA 传输完成标志 */ uint8_t FilterComplete_Flag; /* ADC 滤波完成标志 */ uint16_t SamplingValue[ADC1_DMA_ARRAY_SIZE]; /* ADC 转换值 */ uint16_t FilterValue; /* ADC 二阶滤波值 */ float Voltage; /* ADC 电压值 */} ADC1_VarGroup_TypeDef; 另外，如若要通过指针访问结构体，则需要注意字节对齐，可用以下方法自定义对齐： 123456789#pragma pack (push, 1) /* 作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐 */typedef struct { uint8_t DMA_TC_Flag; /* DMA 传输完成标志 */ uint8_t FilterComplete_Flag; /* ADC 滤波完成标志 */ uint16_t SamplingValue[ADC1_DMA_ARRAY_SIZE]; /* ADC 转换值 */ uint16_t FilterValue; /* ADC 二阶滤波值 */ float Voltage; /* ADC 电压值 */} ADC1_VarGroup_TypeDef;#pragma pack(pop) /* 作用：恢复对齐状态 */ 函数、变量、宏、结构体、联合体等的命名注意规范，缩写采用公认缩写，使名称易于阅读，不使用自造的冷门缩写。命名标准如下示例： 123456789101112131415161718192021void I2C_DataTransmit(uint8_t *pBuffer, uint8_t NumOfBytes);typedef enum { LEVEL_LOW = 0, LEVEL_HIGH = 1,} GPIO_LevelState_TypeDef;status_t PINS_DRV_Config(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_LevelState_TypeDef GPIO_State);uint8_t *g_pBuffer = NULL; /* 定义一个全局指针 */#define FPGA_PWR_EN 1Utypedef struct { uint8_t Hall_W; /* 霍尔 */ uint8_t Hall_V; /* 霍尔 */ uint8_t Hall_U; /* 霍尔 */ uint8_t Break_In; /* 刹车输入 */ uint8_t FR_In; /* 正反转 */ uint8_t EN_In; /* 电机使能 */} GPIO_PinLevel_TypeDef; 注意某些标准库函数以及其它自己编写的不可重入函数的使用，例如 printf(); 函数，开发调试时可适当于中断程序中使用，但在项目的Release阶段，务必检查中断中有无使用类似不可重入的不安全函数。 对于编译器优化，务必慎重使用。若不清楚编译器会对哪些函数进行优化，尽量不要使用，以避免优化过后的代码的实际执行情况与自己的真实想法背道而驰，另外，优化级别越高，越不利于调试。 对于一些全局变量，若只于单个c文件内使用，则使用static关键字修饰。 对于全局变量，一般情况下只允许一个修改者，可依据实际情况存在多个读取者。若有多个修改者，则务必给全局变量加上 互斥信号量（互斥锁） 进行保护。 对寄存器的操作，写操作尽量附带掩码（Mask）进行操作。在同一个函数中，对寄存器进行读操作时，先赋值给中间变量，再由中间变量进行之后的条件判断、赋值等操作，切忌直接使用寄存器进行复杂操作，特别是对于输入模式的引脚所对应的一系列寄存器，因为这些寄存器的值可能随时会因为外部电路上电平的变化而发生跳变，如果跳变时正好在使用该寄存器进行一系列连续的操作，则最终可能会出现意想不到的问题，与真实想法背道而驰，严重时会导致崩溃，进入HardFault等错误中断。 慎用递归，特别针对资源紧缺的平台。 慎用goto。 对于频繁变化的变量，尤其是在中断中变化的变量，在定义时务必加上volatile关键字修饰。 在没有硬件浮点单元（FPU）的MCU上进行开发，尽量少用或者不用浮点运算。 在中断中不要进行浮点运算（特别是触发频率较高的中断中），会导致效率低下！ 注意字节对齐，例如4字节对齐、8字节对齐。 尽量不要使用除法运算，使用乘法、位移来替代除法运算。 定义位域时，注意不同硬件平台的大小端问题。 定义结构体时，注意字节对齐！按数据类型从小到大的顺序依次排列，可使内存占用更少，同时字节对齐，降低指针操作结构体成员时指向非法地址的可能性。 对于变量、函数、宏、枚举等的命名，若存在多个针对某一特定实例对象的定义，可把不同的文字置于名称末尾，方便IDE中编辑时的 自动联想 功能（Eclipse系的IDE使用 Alt + / 进行联想），例如： 变量： 12uint8_t *pBuffer_Tx;uint8_t *pBuffer_Rx; 函数： 12void LPI2C_Drv_Init(void);void LPI2C_Drv_Deinit(void); 宏： 12#define FPGA_PWR_ON 1U#define FPGA_PWR_OFF 0U 枚举： 123456enum BEEP_RATE { BEEP_RATE_10MS = 10U, BEEP_RATE_100MS = 100U, BEEP_RATE_1S = 1000U, BEEP_RATE_5S = 5000U,}; 理解逻辑移位和算术移位的区别。 逻辑左移 = 算数左移 逻辑右移就是不考虑符号位，右移一位，左边补零即可。算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。所以算术右移也可以进行有符号位的除法，右移 N 位就等于除以2的n次方。 例如，8位二进制数 11001101 分别右移一位。 逻辑右移 算术右移 [0]1100110 [1]1100110 条件判断语句、运算表达式、宏定义中，每一小部分都用括号显式包含起来，例如宏定义： 1#define PWR_CHECK_OK ((BAT_CHECK_OK) &amp;&amp; (ACC_CHECK_OK)) 尽量显式初始化全局变量，未初始化的全局变量是“弱符号”，有潜在风险。举例：当使用一些外部静态库或动态库时，若库中存在同名且初始化的全局变量，则自己的全局变量会被覆盖，会造成莫明其妙的问题且难以追踪。 弱符号妙用之一：在项目的Release和Debug阶段，通过弱函数和强函数，可将Debug阶段的函数覆盖，以使其在Release阶段不产生效用。例如printf函数。 尽量只让一个函数实现一个单独的功能，而不是一个函数实现多个功能。 尽量控制单个函数的行数，一般情况下不要超过80行。 考虑代码的正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性 编译后生成bin文件： 1C:\\Keil_v5\\ARM\\ARMCC\\bin\\fromelf.exe --bin -o .\\KeilProjFile.bin .\\Objects\\*.axf 经验： 循环体要纯粹，尽量避免循环 循环嵌套时，次数多的安排在内层 循环中避免使用链表 循环体展开 优化思路： 编译器优化开关，直接打开 利用外部profile工具，查找性能瓶颈，按照28法则进行优化。同时关注如何提高系统整体命中率 架构重构，使用不同的实现方法达到相同的目的 —— 优化幅度巨大 最优先考虑算法上的优化 —— 可观 源码级优化（通用手法）—— 一到两倍 根据特定平台进行汇编改写，使用高级指令 —— 提升10%~30%，很少使用 通用源码优化手段： 避免浮点/除法运算 乘法改移位 开根号/求对数，使用快速简化运算 循环展开 循环内部小循环套大循环 循环体内避免出现判断语句 减少函数调用，对于纯粹的，调用频繁的函数进行内联 函数定义不能超过4个参数，如做不到请用结构体将参数打包，传入结构体指针 链接：azillionmonkeys.com 把循环体里的判断干掉 对关键的变量用register（可能没用） else可以想办法去掉 定义二维数组时，外层一定要是2的倍数。int arr[3][23]改为int arr[3][32]; 优化循环：for改为do…while, 并且要递减（效率最高的一种循环模式） 尽量避免赋值时的隐式类型转换（保证数据类型一致） 局部的函数定义为static ……","link":"/2019-09-20-C语言开发标准（微控制器）.html"},{"title":"Astyle 参数设置","text":"A. *.bat批处理文件调用Astyle进行代码格式化[KR风格]1. 一键格式化所有代码(包括子目录)_完整参数版12for /R %%f in (*.c;*.h) do AStyle.exe --style=kr --indent=spaces=4 --attach-closing-while --indent-switches --indent-preproc-define --indent-col1-comments --max-continuation-indent=60 --break-blocks --pad-oper --pad-comma --pad-header --align-pointer=name --align-reference=name --break-one-line-headers --add-braces --attach-return-type --attach-return-type-decl --convert-tabs --max-code-length=200 --suffix=none --verbose %%fpause 2. 一键格式化所有代码(包括子目录)_短参数版12for /R %%f in (*.c;*.h) do AStyle.exe -A3 -s4 -xV -S -w -Y -M60 -f -p -xg -H -k3 -W3 -xb -j -xf -xh -c -xC200 -n -v %%fpause B. Keil调用Astyle进行代码格式化[KR风格] 12345678910111213141516# A.代码格式化-全部文件# [完全名称版(参数过长，Keil中无法正常执行，可用以下短参数版代替)]--style=kr --indent=spaces=4 --attach-closing-while --indent-switches --indent-preproc-define --indent-col1-comments --max-continuation-indent=60 --break-blocks --pad-oper --pad-comma --pad-header --align-pointer=name --align-reference=name --break-one-line-headers --add-braces --attach-return-type --attach-return-type-decl --convert-tabs --max-code-length=200 --suffix=none --verbose \"$E*.c\" \"$E*.h\"# [短参数版]-A3 -s4 -xV -S -w -Y -M60 -f -p -xg -H -k3 -W3 -xb -j -xf -xh -c -xC200 -n -v \"$E*.c\" \"$E*.h\"# B.代码格式化-当前文件# [完全名称版(参数过长，Keil中无法正常执行，可用以下短参数版代替)]--style=kr --indent=spaces=4 --attach-closing-while --indent-switches --indent-preproc-define --indent-col1-comments --max-continuation-indent=60 --break-blocks --pad-oper --pad-comma --pad-header --align-pointer=name --align-reference=name --break-one-line-headers --add-braces --attach-return-type --attach-return-type-decl --convert-tabs --max-code-length=200 --suffix=none --verbose !E# [短参数版]-A3 -s4 -xV -S -w -Y -M60 -f -p -xg -H -k3 -W3 -xb -j -xf -xh -c -xC200 -n -v !E C. Eclipse系IDE调用Astyle进行代码格式化[KR风格](例如 S32 Design Studio, MCUXpresso IDE, TrueStudio, TI Code Composer Studio, Xilinx SDK ……) 位置（例如AStyle放置于以下目录时）D:\\Software\\AStyle\\bin\\AStyle.exe 工作目录${workspace_loc:/${project_name}} 自变量 1234567# 代码格式化-当前文件# [完全名称版(参数过长，Keil中无法正常执行，可用以下短参数版代替)]--style=kr --indent=spaces=4 --attach-closing-while --indent-switches --indent-preproc-define --indent-col1-comments --max-continuation-indent=60 --break-blocks --pad-oper --pad-comma --pad-header --align-pointer=name --align-reference=name --break-one-line-headers --add-braces --attach-return-type --attach-return-type-decl --convert-tabs --max-code-length=200 --suffix=none --verbose ${resource_loc}# [短参数版]-A3 -s4 -xV -S -w -Y -M60 -f -p -xg -H -k3 -W3 -xb -j -xf -xh -c -xC200 -n -v ${resource_loc}","link":"/2019-09-20-Astyle-参数设置.html"},{"title":"CCS 工程配置","text":"注意：自 controlSUITE v200 之后的库版本，库文件名称、目录结构有所变化。 1. 链接文件 Linker Command Files(*.cmd)1234567/* controlSUITE 旧版本库 v125 */C:\\ti\\controlSUITE\\device_support\\f2802x\\v125\\DSP2802x_common\\cmd\\F28027.cmdC:\\ti\\controlSUITE\\device_support\\f2802x\\v125\\DSP2802x_headers\\cmd\\DSP2802x_Headers_nonBIOS.cmd/* controlSUITE 新版本库 v230 */C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_common\\cmd\\F28027.cmdC:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_headers\\cmd\\F2802x_Headers_nonBIOS.cmd 2. 源文件 C Files(*.asm, *.c)1234567/* controlSUITE 旧版本库 v125 */C:\\ti\\controlSUITE\\device_support\\f2802x\\v125\\DSP2802x_common\\source\\C:\\ti\\controlSUITE\\device_support\\f2802x\\v125\\DSP2802x_headers\\source\\DSP2802x_GlobalVariableDefs.c/* controlSUITE 新版本库 v230 */C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_common\\source\\C:\\ti\\controlSUITE\\device_support\\f2802x\\v230\\f2802x_headers\\source\\F2802x_GlobalVariableDefs.c 3. 头文件 Include Options(*.h) Project -&gt; Properties -&gt; CCS Build -&gt; C2000 Compiler -&gt; Include Options -&gt; Add dir to #include search path(–include_path, -I) controlSUITE 旧版本库 v125 - 相对路径1234567${PROJECT_ROOT}${CG_TOOL_ROOT}/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v125/DSP2802x_common/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v125/DSP2802x_headers/include${TI_PRODUCTS_DIR}/controlSUITE/libs/app_libs/motor_control/drivers/f2803x_v2.0${TI_PRODUCTS_DIR}/controlSUITE/libs/app_libs/motor_control/math_blocks/v4.0${TI_PRODUCTS_DIR}/controlSUITE/libs/math/IQmath/v15c/include controlSUITE 新版本库 v230 - 相对路径1234567${PROJECT_ROOT}${CG_TOOL_ROOT}/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v230/f2802x_common/include${TI_PRODUCTS_DIR}/controlSUITE/device_support/f2802x/v230/f2802x_headers/include${TI_PRODUCTS_DIR}/controlSUITE/libs/app_libs/motor_control/drivers/f2803x_v2.1${TI_PRODUCTS_DIR}/controlSUITE/libs/app_libs/motor_control/math_blocks/v4.3${TI_PRODUCTS_DIR}/controlSUITE/libs/math/IQmath/v160/include 4. 预定义宏 Predefined Symbols123_DEBUGLARGE_MODELFLASH 5. Runtime Model Options Place each function in a separate subsection - on","link":"/2019-09-24-CCS-工程配置.html"},{"title":"MISRA-C 2004 规则解读","text":"MISRA-C 2004 规则解读 Ver 1.0.0 Collected By Tomy Stark.E-mail: ro7enkranz@qq.com Note: 本文档由我从互联网整理收集而来，尚需完善，文中可能还存在诸多谬误，若发现有误可邮件联系以修正问题，在此感谢！ 1 S ~ 20 S1 S：Procedure name reused.函数名与变量名称重复。 2 S：Label name reused.局部变量重命名。虽然作用域不同能编译通过，但是容易造成混淆。 3 S：More than N executable reformatted lines in file.规定单个文件代码行数不能超过N，N值可配置。 4 S：Procedure exceeds N reformatted lines.规定单个函数的代码行数不能超过N，N值可配置。 5 S：Empty then clause.空语句有可能是开发人员忘记实现某个功能而留下的坑。所以在确实是空的地方这样写比较合适： 1234567UINT_32 value_x = 1u;if (value_x == 0u) { value_x = value_x + 1u;} else｛ /*do nothing*/｝ 6 S：Procedure pointer declared.避免使用函数指针： 1234567891011121314#include \"c_standards.h\"void foo(UINT_32 p_1, UINT_16 p_2){ /* ... */ }/******************************************************** * Standard 6 S : Procedure pointer declared. ********************************************************/void static_6(void){ void (*proc_pointer) (UINT_32 p_1, UINT_16 p_2) = foo; /* 不建议使用函数指针 */ proc_pointer(1u, 1);} 7 S：Jump out of procedure. 避免使用非局部跳转语句，如setjmp和longjmp函数。 8 S：Empty else clause. 见【5S】。 9 S：Assignment operation in expression. 避免在表达式中使用赋值语句，举个栗子： 123456BOOL static_9(BOOL test){ BOOL result,flag; result = ( flag = test ); /* not compliant */ return result;} 10 S：空 11 S：No brackets to loop body (added by Testbed). 避免省去大括号，举个栗子： 123456for (i = 0; i &lt; 10; i = i + 1) j--; /* not compliant */if (i &gt; 0) { i = i - 1;} else i = i + 1; /* not compliant */ 12 S：No brackets to then/else (added by Testbed). 见【11S】。 13 S：goto detected.避免使用goto语句。 14 S：Procedural parameter declared. 避免使用函数作为函数的参数。 1234567/******************************************************** * Standard 14 S : Procedural parameter declared. ********************************************************/void static_14(void (*p_proc_pointer)(INT_32 p1)){ p_proc_pointer = test_14s;} 15 S：Anonymous field to structure. 避免使用无名称的结构体，这通常出现在结构体嵌套使用的场景。 1234567891011/******************************************************** * Standard 15 S : Anonymous field to structure. ********************************************************/struct s_15 { UINT_32 xs; struct { UCHAR ac; UCHAR ab; }; /* not compliant */}; 16 S：Multiple labels declared. 避免在文件的同一处使用多个标签。 17 S：Code insert found. 避免在代码中嵌套出现汇编语句，大多数编译器是编译不通过的。 18 S：More than N parameters in procedure. 规定单个函数入参个数不能超过N，N值可配置。 19 S：Procedural para used in an uncalled procedure. 避免函数作为参数的情况，即使该函数未被调用，同【14S】。 20 S：Parameter not declared explicitly. 避免入参无变量类型，大多数编译器是编译不通过的。 21 S ~ 40 S21 S：Number of parameters does not match. 函数定义的入参的个数与使用时传入的入参个数不一致。 22 S：Use of obsolete language feature ( use = - ). 不应当使用早期C语言中存在的语法规则，如=- =* =+等运算符。 23 S：Procedure is not called in text analysed. 在main函数的源文件中，如果某个函数不被本文件调用，该函数放在其他的源文件中比较合适。 24 S：Use of Noanalysis annotation. 使用标记某段源代码，这段代码不会被进行静态规则检查。 25 S：Null case(s) in switch statement. 避免某个case语句为空而执行到了下一个case： 12345678910111213141516171819INT_32 static_25(INT_32 p_1){ INT_32 i = 0, j = 0; switch (p_1) { case 0: j = 0; break; case 1: case 2: /* not compliant */ j=i; break; default: i = j + 1; } return i + j;} 26 S：Infinite loop used.避免使用死循环： 123for(;;)while(1) {...}do .. while(1) 27 S：Void procedure with return statement. 函数返回值被定义为void，却仍然有返回值，此条在VS2008中不能编译通过。 28 S：Duplicated Base Classes in a Derived class. 某个类有两个父类，在两个父类中存在同名函数，当子类调用该函数时会造成混乱： 12345678910111213141516171819202122class Base{ public: void func(void);};class Sub1: public Base { /* ... */ };class Sub2: public Base { /* ... */ };/******************************************************** * Standard 28 S : Duplicated Base Classes in a Derived class. ********************************************************/class derived : public Sub1, public Sub2 { /* ... */ }; // not compliantvoid static_028 ( void ){ derived d; d.func(); // ambiguous whether Sub1::Base::func() // or Sub2::Base::func()} 29 S：Use of += or -= operators found. 避免使用+= 或者 -=运算符。 30 S：Deprecated usage of ++ or – operators found. 避免在表达式中使用连+或-符号： 123456789101112131415void static_30(void){ INT32_t x = 1u; INT32_t y = 2u; BOOL flag = FALSE; if (flag == FALSE) { x++; /* compliant */ } x = x + y++; /* not compliant */ func( x++ ); /* not compliant */} 31 S：Use of break statement in loop. 避免在循环中使用break语句，建议用置标识的方法跳出循环。 32 S：Use of continue statement.避免在循环中使用continue语句，建议用置标识的方法控制循环。 33 S：Use of ternary operator found.避免使用三目运算符。 34 S：No parameters declared in proc specification. 在函数声明时无参数，在函数实现时却有参数，在VS2008下编译不通过。 35 S：Static procedure is not called in text analysed. 函数被声明为static类型，却没有在本文件调用，那么static修饰符是不必要的。 36 S：Function has no return statement. 函数不为void类型却无返回值。 37 S：Procedure parameter has a type but no identifier. 避免函数参数有类型却忽略变量名： 123456void static_37 ( UINT32_t ); /* not compliant */void static_37 ( UINT32_t ) /* not compliant - constraint error */{ /*do something*/} 38 S：Use of static class member. 不建议对类中的变量和函数使用static修饰符。 39 S：Unsuitable type for loop variable. 有些类型不适合当作控制循环的变量，如float类型： 123456789void static_39( void ){ FLOAT32_t f = 0.0F; for (f = 0.0F; f &lt; 10.0F; f = f + 1.0F) /* not compliant */ { /* ... */ ; }} 40 S：Loop index is not declared locally. 避免控制循环条件的变量不在本函数内声明，有可能引起循环判断的条件失控： 12345678910INT32_t loop_standards (INT32_t p_1){ INT32_t r = 10; for (global_f = 0; global_f &lt; 10; global_f = global_f + 1) /* not compliant */ { r--; } return r;} 41 S ~ 60 S41 S：Ellipsis used in procedure parameter list. 函数入参中使用省略符号，省略符号允许不确定的入参个数，建议避免该编程方式的使用。 42 S：Use of bit field in structure declaration. 避免在结构体声明中使用位字段 1struct bitfield1 {INT_32_t x:1;}; /* not compliant */ 43 S：Use of setjmp/longjmp. 避免使用setjmp/longjmp语句，使用该语句使得程序移植性差，结构混乱。 44 S：Use of banned function or variable. 不允许使用关键字命名变量和函数，避免使用与库文件中同名的函数和变量。 45 S：Use of C++ keyword. 不允许使用C++关键字： 12345678910111213141516void static_45(void){ UINT32_t public = 0; /* not compliant */ UINT32_t private = 0; /* not compliant */ UINT32_t protected = 0; /* not compliant */ UINT32_t operator = 0; /* not compliant */ UINT32_t new = 0; /* not compliant */ UINT32_t template = 0; /* not compliant */ UINT32_t virtual = 0; /* not compliant */ UINT32_t delete = 0; /* not compliant */ UINT32_t friend = 0; /* not compliant */ UINT32_t cout = 0; /* not compliant */ UINT32_t cin = 0; /* not compliant */ UINT32_t endl = 0; /* not compliant */ /* ... */} 46 S：extern not in nominated include file.在某些程序中，只有指定的文件可以使用extern修饰符，如果不在指定的文件中使用extern修饰符静态测试会提示警告。 47 S：Array bound exceeded. 使用数组下标获取数组内容时，需要对越界进行防护。 48 S：No default case in switch statement. 避免在使用switch语句时无default分支： 49 S：Logical conjunctions need brackets. 逻辑运算符连接的判断条件，需要使用括号来包围。 123456789101112131415void static_49(void){ BOOL flag = TRUE; INT_32 y = 0, x = 0, z = 1; if (x &lt; 0 || z + y != 0) /* not compliant */ { flag = FALSE; } if ((x &lt; 0) || (z + y != 0)) /* compliant */ { flag = FALSE; }} 50 S：Use of shift operator on signed type. 避免对有符号数使用移位运算符： 51 S：Shifting value too far. 避免在移位操作中移动跨度过长。 52 S：Unsigned expression negated.对有符号变量进行运算，有造成变量翻转的风险。 53 S：Use of comma operator.避免使用逗号运算符。 54 S：Sizeof operator with side effects. 不能对表达式使用sizeof操作符。 55 S：Expression with more than one function. 避免在一个表达式中使用两个函数的返回值。 56 S：Equality comparison of floating point. 避免对两个浮点型数据进行比较。 57 S：Statement with no side effect. 避免出现即不改变逻辑又不进行赋值的无效语句。 58 S：Null statement found. 在某个控制语句前出现空行代码，这个空行有可能是开发人员忘记了实现某个功能而留下的坑,如果确实想空一行再写代码，建议补充注释： 12345678910void static_58(void){ UINT32_t Timing_Loop = 100U; /* not compliant - decrement is not part of loop */ while (Timing_Loop &gt; 0U); Timing_Loop--; ; /* compliant as followed by comment */} 59 S：Else alternative missing in if. 在与if/else if配对中缺少else的分支： 1234567891011121314void static_59 (void){ UINT32_t x = 1u; if ( x == 1u ) { /* ... */ ; } else if ( x == 5u) { /* ... */ ; } /* not compliant */} 60 S：Empty switch statement. 避免出现空switch(无case的情况)语句。 61 S ~ 80 S61 S：Switch contains default only. 避免switch语句只有default分支而没有case分支。 62 S：Switch case not terminated with break. 建议每个case分支都有break语句。 63 S：Empty parameter list to procedure/function. 函数无入参时，建议增加void修饰： 1234void static_63(void) /* compliant */{ /* ... */} 64 S：Void procedure used in expression. 函数返回值为void类型，却对返回值进行操作，这在vs2008中是编译失败的。 65 S：Void variable passed as parameter. 避免使用void类型修饰函数入参： 12345678910111213141516171819void void_para_func(void P1){ /* ... */}/****************************************************************** * Standard 65 S : Void variable passed as parameter. * Does not Compile with VC++ ******************************************************************/void static_65( void ){ void v_ptr; UINT32_t a; void_para_func(v_ptr); /* not compliant */ void_para_func((void)a); /* not compliant */} 66 S：Function with empty return expression.定义有返回值的函数，却什么也没有返回，这在vs2008中是编译失败的。 12345UINT32_t static_66 ( void ){ /* ... */ return; /* not compliant */} 67 S：#define used in a block. define语句应当出现在文件开头处，不应当在函数体内使用。 68 S：#undef used. 避免使用#undef语句。 69 S：#pragma used. 避免使用#pragma语句。 70 S：Logical comparison of pointers. 对指针的比较只允许使用（== and !=） 12345char * x;char * y;....if (x&gt;y) { /* Incorrect, Unsafe*/ }if (x==y) { /* Correct usage*/ } 71 S：Pointer assignment to wider scope. 该规则用于检查对象的指针是否被分配给超过其作用域范围的值。 由于局部变量在运算完成后，指针指向的变量空间可能被收回，那么被赋值的外部变量可能指向未知的值。 12345678910111213UINT32_t *ptr;UINT32_t* static_71(void){ static UINT32_t w = 10u; UINT32_t local = 3U; UINT32_t *local_ptr = &amp;local; ptr = &amp;local; /* Not Compliant */ ptr = local_ptr; /* Not Compliant */ return &amp;w; /* Not Compliant if modifier is set to 0 */} 72 S：Signed bit field less than 2 bits wide.有符号型变量有一位表示符号，至少还需要一位表示值。 73 S：Bit field not signed or unsigned int.位字段被定义成其他类型是危险的： 1234struct static_73{ UCHAR x:1; /* Not Compliant */}; 74 S：Union declared. 避免使用联合定义数据结构。 75 S：Executable code before an included file. #include语句必须出现在可执行语句之前。 76 S：More than one of # or ## in a macro. 不允许宏定义中出现多个 # 或者 ##： 12/* not compliant */#define SetVariable(Variable, Value) (dummy(NewString##Variable, #Value)) 77 S：Macro replacement list needs parentheses. 使用宏定义时，注意使用括号来限定宏运算的边界，避免在宏被替换后出现意想不到的运算组合： 12345678910111213141516#define increment_NOK(a) (a) + 1#define increment_OK(b) ((b) + 1)/******************************************************** * Standard 77 S : Macro replacement list needs parentheses. ********************************************************/void static_77(void){ INT32_t result = 1; result = increment_NOK(result) * 2; /* result = 3 */ result = 1; result = increment_OK(result) * 2; /* result = 4 */} 78 S：Macro parameter not in brackets. 同77 S： 12#define abs(x) (((x) &gt;= 0) ? (x) : -(x)) /* Compliant */#define abs(x) x &gt;= 0 ? x : -x /* Not compliant */ 79 S：Macro contains unacceptable items. 宏定义中避免出现关键字： 12/* not compliant */#define t void 80 S：Pointer indirection exceeds 2 levels. 避免使用二级指针。 81 S ~ 100 S81 S：Use of trigraphs. C语言不允许使用三字母词，编译不能通过： 1234void static_81(void)??&lt; /* not compliant */ /* ... */} 82 S：Use of wide string literal. 避免使用宽字符类型： 123456void static_82(void){ wchar_t WideChar = L'1'; /* not compliant */ /* ... */} 83 S：Octal number found. 由于8进制数以0开头，容易造成混淆，所以在代码中应当避免使用八进制计数： 1234code[1] = 109; /* set to decimal 109 */code[2] = 100; /* set to decimal 100 */code[3] = 052; /* incorrect - set to decimal 42 */code[4] = 071; /* incorrect - set to decimal 57 */ 84 S：Register variable declared. 避免使用Register关键字修饰变量： 123456void static_84(void){ register SINT_32 ri = 0; /* not compliant */ /* ... */} 85 S：Incomplete initialisation of enumerator. 初始化枚举类型时候，或者全部默认，或者全部初始化，或者只初始化第一个值，其他的初始化方式是不妥的： 1234enum VAL {x, y, z}; /*GOOD - no explicit initialisation*/enum VAL {x = 1, y, z}; /*GOOD - first value only*/enum VAL {x = 2, y = 3, z = 4}; /*GOOD - all values set*/enum VAL {x, y, z = 1}; /*BAD*/ 86 S：Attempt to define reserved word.避免define保留字段。 87 S：Use of pointer arithmetic. 避免对指针使用数学运算： 123456789void static_87(void){ UINT32_t w; UINT32_t array[5]; UINT32_t * p1_ptr; p1_ptr = array; w = *(p1_ptr + 8); /* not compliant */} 88 S：Procedure is not pure assembler. 避免C语言与汇编语言混合使用。 89 S：char type not signed or unsigned. char类型建议定义为signed或者unsigned类型。 90 S：Basic type declaration used. 对于不同编译器基础类型的宽度可能不同，该建议在程序编写前做如下定义： 12345678910typedef char CHAR_t;typedef unsigned char UCHAR_t;typedef unsigned short UINT16_t;typedef unsigned int UINT32_t;typedef signed char SCHAR_t;typedef signed short SINT16_t;typedef signed int SINT_32_t;typedef float FLOAT_32_t;typedef double FLOAT_64_t;typedef enum {FALSE = 0, TRUE = 1} BOOL_t; 91 S：Name redeclared in another C name space (MR). 尽管C语言允许在不同的作用域定义相同的变量名，为避免混淆建议定义不重名变量（在复杂系统中该条很难实现）。 123456789101112131415struct s_91{ UINT32_t s_91; /* not compliant */ UINT32_t u_1;};UINT32_t static_91 (void){ UINT32_t var_1; static_91: /* not compliant */ var_1 = 1; return (var_1);} 92 S：Duplicate use of a name in an enumeration.针对枚举类型，建议不使变量重名： 1234567void static_92 (void){ enum Name_type { e1, duplicate } EnumVar; EnumVar = e1; /* ... */} 93 S：Value is not of appropriate type.强制要求类型检查，不同类型之间转换需要显示转换： 12345678void STATIC_93(void){ FLOAT_32 fl; fl = 2.0; /* not compliant - Requires explicit assignment of 2.0F */ /* ... */} 94 S：Casting operation on a pointer. 避免对指针进行强制类型转换（通过修改测试软件配置，可以允许指针在同类型之间转换）： 123456static void static_94(UINT_32 * p1_ptr){ FLOAT_32 v_1; v_1 = (FLOAT_32) p1_ptr;} 95 S：Casting operation to a pointer. 给指针赋值安全的方式是通过获取对象地址，强转赋值的方式有风险： 1234567struct Astruct { UINT_32 a; };void static_95(UINT_32 *intptr){ struct Astruct *Astructptr; Astructptr = (struct Astruct *) intptr; /* not compliant */} 96 S：Use of mixed mode arithmetic. 不同类型的变量进行数学运算，需要进行强制转换： 123456789static void static_96(void){ INT32_t i32 = 10; FLOAT64_t f64 = 20.5; FLOAT32_t f32 = 2.0F; f64 = i32 + f64; /* not compliant */ f64 = f64 * f32; /* compliant */} 97 S：Use of redundant cast. 避免使用不必要的强制类型转换： 123456void static_97(void){ SINT32_t sx,sy = -10; sx = (SINT32_t) sy + 1; /* not compliant */} 98 S：Actual and formal parameters inconsistent (MR).函数调用时传入的参数类型与定义时不一致。 99 S：Function use is not a call.函数缺少声明。 100 S：#include filename is non conformant. include语句中禁止使用 字符’ \\ /*。 1#include &lt;\\ctype.h&gt; /* not compliant */ 101 S ~ 120 S101 S：Function return type inconsistent. 函数的实际返回值类型与定义的返回值类型不同： 1234567891011121314151617181920UINT32_t static_101( UINT32_t par_1){ switch (par_1) { case 0: return (-1); /* not compliant */ break; case 1: return (1U); break; case 2: return (1L); /* not compliant */ break; case 3: return (1.0f); /* not compliant */ break; default: break; }} 102 S：Function and prototype return inconsistent (MR). 函数声明时的返回值类型与实际使用时的返回值类型不同: 123456789101112UINT32_t static_102(UINT32_t p_1, UINT16_t p_2);/************************************************************** * Standard 102 S : Function and prototype return inconsistent. **************************************************************/SINT32_t static_102(UINT32_t p_1, UINT16_t p_2) /* not compliant */{ SINT32_t result = 0; /* ... */ return result;} 103 S：Function and prototype param inconsistent (MR). 函数声明时的参数类型与实际使用时的参数类型不同： 1234567891011BOOL static_103(FLOAT32_t up_1);/*************************************************************** * Standard 103 S : Function and prototype param inconsistent. ***************************************************************/BOOL static_103(UINT32_t up_1){ BOOL ret = FALSE; /* ... */ return ret;} 104 S：Struct field initialisation incorrect. 结构体初始化赋值的类型与定义的类型不符： 123456789101112131415struct s_type_a{ SINT32_t xs; FLOAT32_t fs;};/******************************************************** * Standard 104 S : Struct field initialisation incorrect. ********************************************************/void static_104(void){ struct s_type_a sta = {3.14F, 0.0f}; /* not compliant */ /* ... */} 105 S：Initialisation brace { } fault. 初始化结构体忘记使用大括号会出错： 123456789101112131415161718192021struct pixel{ UINT32_t colour; struct { UINT32_t x, y; } coords;};/*********************************************************** * Standard 105 S : Struct field initialisation brace fault. ***********************************************************/void static_105(void){ UINT32_t xs = 0; UINT32_t ys = 0; struct pixel spot = {1u, xs, ys }; /* not compliant */ /* ... */} 106 S：Volatile declaration.避免使用Volatile修饰变量，Volatile可以在应用程序外被改变，容易造成逻辑混淆。 12345678void static_106(void){ volatile UINT32_t v = 1U; /* not compliant */ UINT32_t x = 0; x = v; /* ... */} 107 S：Type mismatch in ternary expression. 使用三目运算符时类型不匹配： 1234567static void static_107( BOOL flag ){ UINT32_t x = 0U; FLOAT32_t f = 0.0F; x = (flag ? f : x);} 108 S：Assignment types do not match. 变量赋值时类型不匹配： 1234567void static_108(void){ FLOAT32_t fl = 2.0F; FLOAT_64 dbl = 3.0; fl = dbl; /* not compliant */} 109 S：Array subscript is not integral. 数组的索引必须为正数。 110 S：Use of single line comment //. 由于使用双斜杠标记注释的做法不是对所用的编译器通用，建议对注释段使用/**/的方式。 111 S：Label is not part of switch statement . 只有在switch语句中使用标签语法是安全的。 112 S：Typedef name redeclared.使用typedef 时某个名称被重复使用是危险的： 123456789101112typedef SINT32_t mytype;/******************************************* * Standard 112 S : Typedef name redeclared. ********************************************/void static_112(void){ typedef FLOAT32_t mytype; /* not compliant */ /* ... */} 113 S：Non standard character in source.源文件中出现非法字符，合法的字符如下： 12343***** The lines of permissible characters,(80A1),those NOT changedABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz()[].!~+-*/%&lt;&gt;=&amp; ^|?:;,0123456789_{}'\"#\\$@&lt;space&gt;&lt;tab&gt; 114 S：Expression is not Boolean. 表达式类型不为BOOl类型，或者表达式的运算对象都为BOOL类型： 123456789101112131415161718void static_114(BOOL bl, UINT32_t a){ UINT32_t x; BOOL flag; flag = bl + bl; /* not compliant */ if (a) /* not compliant */ { ; /* ... */ } if (a == 1) /*compliant */ { ; /* ... */ } x = ( a &amp;&amp; bl ? 1U : 0U ); /* not compliant */} 115 S：String incorrectly terminated. string类型换行时需要使用反斜杠，否则在某些编译器中造成string类型结尾异常的错误： 1234567891011/******************************************************* * Standard 115 S : String incorrectly terminated. *******************************************************/void static_115(void){ CHAR* str1 = \"string\\ literal\"; /* compliant */ CHAR* str2 = \"string literal\"; /* not compliant */ } 116 S：Boolean comparison with 0 preferred. 与一个已知值的变量进行比较时，使用不等号来判断FALSE比使用等号判断TRUE安全： 12345678910111213void static_116 (void){ UINT32_t x = 2u; if ( x == 1u ) /* not compliant */ { /* ... */ ; } if ( x != 1u ) { /* ... */ ; }} 117 S：Logical negation of constant value. 对const变量取反是危险的： 123456789void static_117(void){ BOOL flag = FALSE; if (flag == (BOOL)!1) /* not compliant */ { /* ... */ }} 118 S：main must be int (void) or int (int,char* []).C语言Main函数的格式必须是int (void) 或者 int (int,char* [])。 119 S：Nested comment found.避免在注释中出现子注释： 123456void static_119(void){ /* This is the Outer Comment /* This is the Inner Comment - not compliant */} 120 S：Use of bit operator on signed type. 避免对有符号类型进行位运算： 12345678void static_120(void){ SINT32_t b = 1; b = b | 1; /* not compliant */ /* ... */} 121 S ~ 140 S121 S：Use of boolean expression in switch. 避免在switch case语句中使用BOOL类型： 1234567891011121314void static_121(void){ BOOL flag = FALSE; switch (flag) /* not compliant */ { case TRUE: break; case FALSE: break; default: break; }} 122 S：Use of abort, exit, etc. 避免使用语法abort, exit, etc: 1234567891011/******************************************************** * Standard 122 S : Use of abort, exit, etc. ********************************************************/void static_122(BOOL flag){ if (flag) { abort(); } exit(0);} 123 S：Use of underlying enum representation value. 枚举类型只允许在同类型之间比较： 12345678910void static_123(void){ enum E_type { Enum1, Enum2 , Enum3}; UINT32_t ui; ui = Enum1; /* not compliant */ /* ... */} 124 S：Use of prefix ++ or –. 尽量少使用自增或自减运算符。 125 S：Use of ## or # in a macro. 为避免意外的结果发生，不要在宏定义中使用##或#。 126 S：A #if has no #endif in the same file.#if和#endif需要成套使用。 127 S：Array has no bounds specified. 数组声明时候信息需要完整： 123456void static_127( INT32_t par[] ) /* not compliant, unless modifier 286 set */{ INT32_t array[] = {0, 1, 2}; /* not compliant, unless MISRA-C:2004 used */ /* ... */} 128 S：Parameter has same name as global variable. 函数参数名避免与全局变量重名。 129 S：Parameter has same name as type or tag. 函数参数名避免与结构体重名。 130 S：Included file is not permitted. 某些头文件在测试工具中规定不允许使用。 131 S：Name reused in inner scope. 避免内部变量与外部变量重名。 132 S：Assignment operator in boolean expression.bool表达式中避免出现变量赋值语句： 123456789void static_132(void){ BOOL flag = FALSE; if (flag = FALSE) /* not compliant - should be (flag == FALSE) */ { /* ... */ }} 133 S：Assignment operator in RHS of &amp;&amp; or ||.运算符两侧避免出现赋值语句： 12345678910void static_133(void){ BOOL flag = FALSE; INT32_t y = 0, x = 0; if (flag &amp;&amp; ((x = y) == 0)) /* not compliant */ { /* ... */ }} 134 S：Volatile variable in complex expression. 避免使用Volatile修饰变量，更不要在复杂表达式中使用Volatile变量。 135 S：Parameter list is KR. 某些编译器支持函数参数声明时只声明名称而不定义类型，在使用时再定义类型，应当避免这种老式用法： 123456void static_135(p_1, p_2) /* not compliant */UINT32_t p_1;UINT32_t p_2;{ /* ... */} 136 S：Bit operator with boolean operand. bool表达式中避免使用位操作符，因为位操作符（|或者&amp;）容易与连接符（||或者&amp;&amp;）混淆。 137 S：Bit operator acting on boolean value. 同136S 138 S：Anonymous bit field used in structure.避免在结构体位域中使用匿名方法： 12345678910111213struct bad{ UINT32_t x : 1; UINT32_t : 1; UINT32_t z : 1;}struct good{ UINT32_t x : 1; UINT32_t y : 1; UINT32_t z : 1;} 139 S：Construct leads to infeasible code.指在代码中某个逻辑导致部分语句不可达，例如两个常量的比较，结果是恒真或假的，又比如两个并列的条件是耦合的： 1234567891011121314151617181920212223242526typedef enum{ LANE_0 = 0, LANE_1 = 1, LANE_LAST = 3} lane_t;extern lane_t get_lane (void);/******************************************************** * Standard 139 S : Construct leads to infeasible code. ********************************************************/void static_139(void){ lane_t lane = get_lane(); if ((lane &gt; LANE_0) &amp;&amp; (lane &lt;= LANE_LAST)) /* not compliant - False branch of 'lane &lt;= LANE_LAST' never reached */ { /* ... */ } if (defval) /* not compliant - True branch never reached*/ { /* ... */ } if (0) { /* NEVER EXECUTED */ } else {...};} 140 S：Infeasible loop condition found. 避免在循环中出现恒真或恒假的条件： 1234567891011121314#define defval 0/******************************************************** * Standard 140 S : Infeasible loop condition found. ********************************************************/void static_140(void){ while (0) /* not compliant */ { /* ... */ } while(defval) /* not compliant */ { /* ... */ }} 141 S ~ 160 S141 S：Incomplete structure or class declaration. 结构体或者类声明不完整： 123456struct atagname; /* not compliant */struct atagname{ UINT32_t A; UINT32_t B;}; /*compliant */ 142 S：Parameter list declarations are inconsistent. 函数某些参数缺少类型或者名称: 1234void static_142(UINT32_t , UINT16_t p_2) /* not compliant */{ /* ... */} 143 S：Curly brackets used in expression. 表达式中使用大括号会对某些编译器造成干扰，应当避免使用： 123456UINT32_t static_143(UINT32_t p_1){ UINT32_t result; result = p_1{}; /* not compliant */ return result;} 144 S：Floating point not permitted. 避免使用浮点类型，尤其是对浮点类型的操作，应为对浮点类型的操作可能使精度降低： 123456FLOAT32_t static_144(FLOAT32_t p_1,FLOAT32_t p_2) /* not compliant */{ FLOAT32_t result; /* not compliant */ result = p_1 + p_2; return result;} 145 S：#if has invalid expression. #if语句后应当为BOOL类型，如下的表达式写法对有些编译器会造成误解： 1#if MACRO_NAME JUNK_NAME 146 S：#define with empty parameter list.注意使用#define定义表达式，参数为空的情况，如下给出了建议的写法： 12#define Macro() some_macro_body /* not compliant */#define Macro some_macro_body /* compliant */ 147 S：Spurious CHAR_tacters after preprocessor directive. 避免出现不必要的字符，注意下面情况中结尾的分号是不必要的： 12345#ifdef STATIC_147typedef unsigned CHAR_t UCHAR_t;#endif ; /* not compliant */ 148 S：No return type for function/procedure. 函数缺少返回类型,vs2008下编译失败: 123456static_148(UINT32_t p1); /* not compliant */static_148(UINT32_t p1) /* not compliant */{ /* ... */} 149 S：Reference parameter to procedure is reassigned. 传入函数的引用参数在函数内被重新赋值： 12345678910111213141516171819202122CHAR_t *static_149(CHAR_t *p1);void test_149(void){ CHAR_t *a = \"Query\"; CHAR_t *b; b = static_149(a);}/******************************************************** * Standard 149 S : Reference parameter to procedure is reassigned. ********************************************************/CHAR_t *static_149(CHAR_t *p1){ static CHAR_t *newA = \"Response\"; p1++; /* not compliant */ p1 = p1+1; /* not compliant */ p1 = newA; /* not compliant */ return p1;} 150 S：Volatile or const used in function type. 对函数的返回值使用Volatile 或者 const修饰是无意义的： 123456789101112volatile UINT32_t STATIC_150(void); /* not compliant *//*********************************************************** * Standard 150 S : Volatile or const used in function type. ***********************************************************/volatile UINT32_t STATIC_150(void) /* not compliant */{ volatile UINT32_t r; /* ... */ return r;} 151 S：Use of global variable in macro definition. 避免在宏定义中使用全局变量： 123UINT32_t globvar;#define STATIC_151 globvar /* not compliant */ 152 S：Use of a comment in a macro definition.宏定义语句中不建议增加注释，注释内容可以写在语句上一行： 1#define STATIC_152 3 /* not compliant comment */ 153 S：Use of a comment in a pre-processor directive.同147S，在编译器不解析的地方不建议出现注释行： 123#ifdef STATIC_153 /* A Comment - not compliant */ /* ... */#endif /* Another Comment - not compliant */ 154 S：Nested header files found. 避免嵌套包含头文件，需要的头文件建议直接包含： 12345678Static_154_1.h#include \"c_standards.h\"Static_154.h#include \"Static_154_1.h\"Static_154.c#include \"Static_154.h\" /* not compliant，proposal to included c_standards.h directly*/ 155 S：Comments between preprocessor directives. 避免用#ifdef语句来写注释，防止#ifdef语句中的变量被定义后，注释被编译报错： 123#ifdef STATIC_155 this acts as a comment, as STATIC_155 is undefined.#endif 156 S：Use of ‘defined’ keyword in macro body. 宏定义中避免使用’defined’关键字： 1#define STATIC_156(x) defined(x) /* not compliant */ 157 S：Modification of string literal. string类型存储在内存的只读块，改变string类型的字符是危险的： 1234567void static_157(void){ CHAR_t *c = \"1234567890\"; c[7] = '0'; /* not compliant */ *(c+6) = '1'; /* not compliant */} 158 S：Expression with more than N subconditions.并列条件超过N时报警，N值是可配置的： 12345678910111213void static_158(void){ INT32_t a1,b1,c1,d1,e1; INT32_t a2,b2,c2,d2,e2; INT32_t a3,b3,c3,d3,e3; if ((a1==0) &amp;&amp; (b1==0) &amp;&amp; (c1==0) &amp;&amp; (d1==0) &amp;&amp; (e1==0) &amp;&amp; (a2==0) &amp;&amp; (b2==0) &amp;&amp; (c2==0) &amp;&amp; (d2==0) &amp;&amp; (e2==0) &amp;&amp; (a3==0) &amp;&amp; (b3==0) &amp;&amp; (c3==0) &amp;&amp; (d3==0) &amp;&amp; (e3==0)) /* not compliant */ { /* ... */ }} 159 S：Comparing pointer with zero or NULL.指针与NULL比较时，建议对NULL进行类型转换与指针类型一致： 123CHAR_t *message;if (message != (CHAR_t *)(NULL)) /* compliant */if (message != NULL ) /* not compliant */ 160 S：Loop in macro expansion. 避免在宏定义中出现循环，下面的写法除了增加代码行数外是无意义的： 123456#define A B#define B A#define C D#define D E#define E C 161 S ~ 180 S161 S：Declaration in for statement. 避免在for循环中定义变量： 123456789void STATIC_161(void){ UINT32_t x, y=0; for(unsigned x(0);x &lt;3;x++) /* not compliant */ { y++; }} 162 S：Method defined within class declaration. 除了成员函数，不要在类申明中定义函数。 163 S：Function starts with upper case character. 建议与175S一起取消。 164 S：Use of void * pointer. 避免使用void类型指针： 123456789101112static void proc(void *ptr) { ; } /* not compliant */void *a_proc (void) /* not compliant */{ return NULL;}void static_164 (void){ void * p = a_proc(); /* not compliant */ proc(p);} 165 S：Nested class declaration. 避免嵌套使用类： 123456789101112131415class one {public: long along; class nested { public: short s; nested(){;} }; one() { nested anest; }}; 166 S：Class declared in function body.避免在函数体内定义类： 123456789101112131415class one {public: long l; one(){;} void aproc() { class inproc1 { public: short s; inproc1(){;} }; }}; 167 S：Class variable declared in class definition. 建议不要直接在结构体或者类定义后申明变量，使用typedef是更好的做法： 123456class one {public: long a; one(){;}} aone, *paone; 168 S：Call by value parameter not const. 值类型的函数参数传递建议使用const修饰: 12345678910static void aproc(SINT32_t iv_param) {;} /* not compliant */static void bproc(const SINT32_t ic_param) {;}static SINT32_t static_168 (void){ SINT32_t loc_var = 0; aproc(loc_var); bproc(loc_var);} 169 S：Use of forward reference of class member. 注意在类中变量的定义要在使用之前： 12345678910111213class ok{public: INT32_t x; ok(void) { x = 1; }};class notok{public: notok() { d = 91; /* not compliant */ } INT32_t d;}; 170 S：Procedure call has no prototype and no defn. 被调用的函数缺少申明或者定义。 171 S：已取消 172 S：Variable declared multiply.变量重复定义： 12345678910UCHAR_t ddd;UCHAR_t ddd; /* not compliant */UCHAR_t ddd = 0U;static void static_172(void){ ;} 173 S：Class member starts with upper case character.类的函数应当以小写字符开头命名（构造函数除外）： 1234class one {public: void Upper2_out(); /* not compliant */}; 174 S：Class member starts with lower case character.类的成员函数应当以大写字符开头命名： 12345678class one {public: INT32_t x; void notokproc1 () /* not compliant */ { }}; 175 S：Function starts with lower case character. 建议与163S一起取消。 176 S：Non standard escape sequence in source. 避免出现转义字符： 12345678910111213void static_176(void){ char c = 'b'; switch(c) { case '\\m': /* not compliant */ break; default: break; }} 177 S：Identifier not declared on new line. 建议每个变量都单起一行定义： 1234567INT32_t okvar, notok2; /* not compliant */void static_177(void){ okvar = 0; notok2 = 2;} 178 S：Declaration statement not on new line.同177S： 1234567891011INT32_t * oka;INT32_t b; INT32_t *notoka; /* not compliant */void proc(INT32_t * s, INT32_t *ok); /* compliant */struct tag0 {INT32_t * w; INT32_t *notokq;} astr; /* not compliant */static void static_178(void){ oka = 0;} 179 S：Extern not at start of header file. extern类型变量应当声明在源文件开头处： 123456789101112131415161718192021#include \"c_standards.h\"#include \"Static_179.h\"/******************************************************** * Standard 179 S : Extern not at start of header file. ********************************************************/static void static_179(void){ ;}/* * Copyright (c) 2001 Liverpool Data Research Associates * * */Static_179.hINT32_t var;extern INT32_t ex; /* not compliant */ 180 S：No space between * or &amp; and name in declaration. * 或者 &amp; 与变量名之间应当有空格。 181 S ~ 200 S181 S：No space between if, while, for and expresn. (if, switch, while, for)关键字后请跟上一个空格： 123456789101112INT_t32_t main(void){ INT_t32_t i=3; if( 1==2 ) {2;} /* not compliant */ switch(i){ /* not compliant */ } switch (i){ } while(i==0){2;} /* not compliant */ do{2;}while(i==0); /* not compliant */ for(i=0;i&gt;2;i++){2;} /* not compliant */} 182 S：No space after semi colon in for expression. for循环表达式中分号后打一个空格，看上去更整洁： 1for ( i = 0; i &lt; 5; i++ ){ i++;} /*compliant */ 183 S：No newline after semi colon. 分号后再起一行，便于阅读： 1234567static void static_183(void){ INT_t32_t i; INT_t32_t j; /* not compliant */ for (i = 0; i &lt; 5; i++) {i++;} /* not compliant */} 184 S：Spaces round -&gt; or [] operators. -&gt; 或 [] 操作符连接处不能有空格： 12345void static_184(struct tag * astr, INT_t32_t b [] /* not compliant */ ){ astr -&gt;f = 2; /* not compliant */} 185 S：Space between unary operator and operand. 单目运算符和操作对象之间不应当有空格： 123456789101112131415void proc(INT_t * g){ * g = 77; /* not compliant */ *g = * g + 77; /* not compliant */}INT_t main(void){ INT_t i = 9; INT_t j = 19; INT_t * p; /* not compliant */ i = - j; /* not compliant */ p = &amp; j; /* not compliant */} 186 S：Space missing before or after binary operator.二目运算符之间缺少空格： 123456789101112INT_t main(void){ INT_t i = 9; INT_t j =8; /* not compliant */ INT_t k= 7; /* not compliant */ UINT_t x = 3; UINT_t y = 17; i= j; /* not compliant */ i = j /k; /* not compliant */ i = j &lt;&lt;k; /* not compliant */ i = j &amp;&amp; k;} 187 S：Tab CHAR_tacter in source. 源文件中使用空格而不是Tab键缩进。 188 S：{ or } not on line by itself. 为了提高可读性，花括号的使用需要注意: 123456789101112131415struct tagnotok { CHAR_t a; } data; /* not compliant */struct{ CHAR_t x;} moredata;void proc_ok(){ ;}void static_188(void) { /* not compliant */ ;} 189 S：Input line exceeds limit. 每一行的字符数不能过多。 190 S：{ … } contents not indented by N spaces. 花括号后一行缩进N个空格，N值可以配置。 191 S：Space between function name and parenthesis. 函数名和括号之间不应当有空格： 123void notokproc1 () /* not compliant */{} 192 S：Static not on separate line in function defn.为了提高代码可读性，inline, static 和 const修饰的函数，修饰符和参数可以分两行写。 193 S：Inline not on separate line in function defn.同192S，内连函数定义中修饰符和函数定义可以分两行写： 1inline void one::mem1(void) /* not compliant */ 194 S：Const not on separate line in member defn.同192S，const修饰符和函数定义可以分两行写。 195 S：Function return type needs a new line. 为了提高代码可读性，函数定义中返回值类型和参数可以分两行写。 196 S：Access specifier missing (added by Testbed). 类定义中成员缺少Public、Protected或Private修饰符。 197 S：Access specifiers in invalid order. 访问权限修饰符在类定义时应当遵循特定的顺序，首先是Public类型，然后是Protected类型，最后是Private类型： 12345678class class_197 {public: INT_t_16 d;private: /* not compliant */ INT_t32_t a;protected: /* not compliant */ INT_t32_t q;}; 198 S：Use of privacy statement in struct.结构体中成员不应当修饰为privacy类型。 199 S：Use of anonymous namespace. 避免使用匿名命名空间。 200 S：Define used for numeric constant. C++中建议const代替宏定义常量，C中建议使用宏代替const定义常量。 201 S ~ 220 S201 S：Use of numeric literal in expression. 该条规则建议使用宏或者枚举代替具体的数字，以提高代码的可维护性。 202 S：Class data is not explicitly private. 建议类中的成员变量为私有。 203 S：Cast on a constant value. 避免对常量进行强制类型转换： 12345678910const INT16_t con = 19;const INT16_t * pcon;static void static_203(void){ INT16_t x; INT16_t *p; x = (INT16_t)con; /* not compliant if modifier = 0 */ p = (INT16_t *)pcon; /* not compliant */} 204 S：continue or goto not defined to rubbish. 避免使用goto和continue语句。 205 S：Use of multiple inheritance. 避免在类中使用复杂的多重继承。 206 S：Class initialiser out of order.类成员初始化的顺序需要与申明时候的顺序一致。 207 S：Use of old style /* comments in C++. 建议C++注释中使用双斜杠。 208 S：Private data name needs trailing underscore. 类的私有变量建议以下划线结尾以做区分: 12345678class MyClass{private: UINT32_t m_ok_item_; UINT32_t m_not_ok_item; /* not compliant */protected:public:}; 209 S：Preprocessor command indented. 宏定义顶头写，不建议有缩进： 1234#ifndef XXX /* not compliant */ #define XXX#endif 210 S：Macro name is not upper case. 建议宏定义变量名大写。 211 S：Overloaded &amp;&amp;, || or comma. 请不要重定义&amp;&amp;, || 或者 comma。 212 S：Use of friend function in class.谨慎的使用友元类，以免在类继承或者重新设计接口是带来隐患。 213 S：Use of friend class.同212S。 214 S：Member not declared virtual.建议基类中函数申明为virtual类型。 215 S：Struct or class called by value. 避免直接使用结构体作为函数的入参，或者作为函数的返回值，这样会消耗额外的内存空间，使用指针是更合理的方式。 216 S：Pointer name does not have required suffix. 建议变量的名称以变量的类型为后缀，增加代码的可读性： 12345678static void static_216(void){ UCHAR_t * pointer; /* not compliant */ UCHAR_t * ptr; /* ok as allowed suffix is ptr */ UCHAR_t * aptr; /* ok as allowed suffix is ptr */ /***/} 217 S：Names only differ by case. 避免出现两个变量仅仅是某些字符大小写不同： 12345678910INT32_t Foobar;INT32_t foobar; /* not compliant */INT32_t fOobar; /* not compliant */void aproc(CHAR_t aC2; INT32_t FooBar) {;} /* not compliant */void static_217(void){ struct tag{ CHAR_t aC1, INT32_t FooBar;} local; /* Ok as different scope */} 218 S：Name is used in standard libraries.命名时避免与C/C++标准库中的名称重复。 219 S：User name starts with underscore. 避免以下划线开始命名变量。 220 S：No prefix for global type. 建议全局变量名称后缀该变量的类型以增加可读性。 221 S ~ 241 S221 S：Start of class/struct/union/enum lower case. 建议结构体和联合体命名以大写字符开头。 222 S：Start of variable is upper case. 建议变量名以小写字符开头。 223 S：No prefix for global function. 作用域为全局的函数名建议以_func结尾以增加代码的可读性。 224 S：Start of enumeration is upper case. 建议常量和枚举类型的变量以小写字符开头。 225 S：Inappropriate file extension. C的源文件类型为.c，C++源文件类型为.cpp。 226 S：Bit field is not octal, hex or suffix u.位字段建议是八进制、十进制或无符号型： 12345678910111213enum { won = 1, too = 2};struct tag{ UINT dec : 2; /* not compliant */ UINT oct : 02; UINT hex : 0x3; UINT enumr : won; /* not compliant */ UINT decu : 3u;}; 227 S：Numeric bit operand is not octal,hex or u. 位操作建议是八进制、十进制或无符号型： 12345678void static_227(void){ UINT x = 1, y; y = x &amp; 20; /* not compliant */ y = x &amp; 20u; y = x &amp; 020; y = x &amp; 0x20;} 228 S：Bracket mismatch ( or { in macro definition. 宏定义中缺少（ 或者｛： 123/* Missing right parenthesis (!) in this macro definition of a 'common' symbolic constant */#define COMMON_SYM_CONSTANT ((2U * 3U) + 2U 229 S：Bracket mismatch ) or } in macro definition. 宏定义中缺少） 或者 ｝： 123/* Missing left parenthesis (!) in this macro definition of a 'common' symbolic constant */#define COMMON_SYM_CONSTANT 2U * 3U + 2U) 230 S：No copy constructor defined for class. 尽管有默认的构造函数，建议自己实现类的构造函数。 231 S：No assignment operator defined for class. 同230S，建议自己实现构造函数并对变量初始化。 232 S：No destructor defined for class.同230S，建议自己实现析构函数。 233 S：No copy constructor for class with pointers.同230S，建议自己实现拷贝构造函数。 234 S：No assignment operator for class with pointers.同231S。 235 S：No destructor for class with pointers. 同232S。 236 S：New used in class without assignment op. 类中使用new分配空间时，建议定义拷贝赋值运算符： 1234567891011121314151617181920212223242526class Person{public: Person(); explicit Person(const UINT_32 personNum); explicit Person(const Person &amp;person); ~Person();protected:private: UINT_32 personalNumber; UINT_32 *skillsList;};Person::Person(const UINT_32 personNum){ personalNumber = personNum; skillsList = new UINT_32[10]; /* not compliant */}static void static_236(void){ Person p1(10); Person q1(10); q1 = p1; /* invokes (compiler provided) copy assignment constructor */} 237 S：Assignment operator parameter not const. 拷贝赋值运算符被用来将一个对象中的值拷贝到同类型的另一个对象中，该对象应当为const类型，不被改变： 12345678910111213141516171819202122232425262728class Person{public: Person(); explicit Person(const Uint_32 personNum); explicit Person(const Person &amp;person); Person &amp; operator=(Person &amp;person); // should be a const parameter ~Person();protected:private: Uint_32 personalNumber;};Person &amp;Person::operator=(Person &amp;person){ if (this != &amp;person) { // Assignment code } return *this;}void foo(void){ Person p1(10); Person q1(10); q1 = p1;} 238 S：Number of templates exceeds N.建议减少使用模版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475template &lt; class T &gt;class tplate1{public: tplate1();protected:private: Uint_32 value1;};template &lt; class T &gt;class tplate2{public: tplate2();protected:private: Uint_32 value2;};template &lt; class T &gt;class tplate3{public: tplate3();protected:private: Uint_32 value3;};template &lt; class T &gt;class tplate4{public: tplate4();protected:private: Uint_32 value4;};template &lt; class T &gt;class tplate5{public: tplate5();protected:private: Uint_32 value5;};template &lt; class T &gt;class tplate6{public: tplate6();protected:private: Uint_32 value6;};template &lt; class T &gt;class tplate7 // This declaration causes a violation when{ // limit configured to 6.public: tplate7();protected:private: Uint_32 value7;};void foo(void){ // ...} 239 S：New used in class without copy constructor. 如果类中使用new分配空间，同时建议定义拷贝构造函数： 123456789101112131415161718192021222324class Person{public: Person(); explicit Person(const UINT_32 personNum); Person &amp; operator=(const Person &amp;person); ~Person();protected:private: UINT_32 personalNumber; UINT_32 *skillsList;};Person::Person(const UINT_32 personNum){ personalNumber = personNum; skillsList = new UINT_32[10]; /* not compliant */}static void static_239(void){ Person p1(10); Person q1(p1); /* invokes (compiler provided) copy constructor */} 240 S：Use of dynamic_cast. 建议减少使用动态类型分配： 1234567891011121314151617181920212223242526272829303132333435363738class Base{public: Base(); explicit Base(const Base &amp;base); Base&amp; operator=(const Base &amp;base); virtual ~Base();protected:private:};class Derived : public Base{public: Derived(); explicit Derived(const Derived &amp;derived); Derived&amp; operator=(const Derived &amp;derived); virtual ~Derived();protected:private:};class DifferentDerived : public Base{public: DifferentDerived(); explicit DifferentDerived(const DifferentDerived &amp;dderived); DifferentDerived&amp; operator=(const DifferentDerived &amp;dderived); virtual ~DifferentDerived();protected:private:};static void static_240(void){ Derived *d1 = new Derived; DifferentDerived *dd1 = dynamic_cast &lt;DifferentDerived *&gt; (d1); /* not compliant */} 241 S：Start of class/struct/union/enum lower case. 建议结构体和联合体命名以大写字符开头。","link":"/2019-09-20-MISRA-C-2004-规则解读.html"},{"title":"Hexo Markdown 小技巧","text":"技巧列表1. 首页文章截断，显示 阅读更多 按钮1&lt;!--more--&gt; 2. 标题级别123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 3. 插入图片123![Car](../images/Car.jpg)![Building](../images/Building.png) 图片效果 4. 插入网页链接1[Hexo Built-in Tag Helpers](https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/Posts/hexo-built-in-tag-helpers/) 链接效果Hexo Built-in Tag Helpers","link":"/2019-09-19-Hexo-Markdown-小技巧.html"},{"title":"Markdown Plus","text":"Markdown PlusMarkdown Plus (“M+” or “mdp” for short) is a markdown editor with extra features. AppsWe currently don’t accept donations.The best way to support our development is to buy our apps. Markdown PlusMarkdown Plus is available for both OS X and Windows. You get every feature of the web version plus lots of advanced features. Markdown MateMarkdown Mate is a markdown previewer, it’s not going to replace your favorite editor but handles everything about markdown. ::: successWe provide email support to those who have purchased the apps: service@tylingsoft.com::: Table of Contents[toc] Note: Only h2 and h3 are shown in toc. Mastering MarkdownMarkdown allows you to write using an easy-to-read, easy-to-write plain text format, which then converts to valid HTML for viewing. Mastering Markdown Guide. strikethrough++insert++==mark==Subscript: H2OYou can also use inline math: $H_2O$ Superscript: 29^th^You can also use inline math: $29^{th}$ Emoji: :panda_face: :sparkles: :camel: :boom: :pig:Emoji Cheat Sheet Fontawesome: :fa-cab: :fa-flag: :fa-bicycle: :fa-leaf: :fa-heart:All the Font Awesome icons print 'hello code'evens = [1, 2, 3, 4, 5].collect do |item| item * 2 end12345$(document).ready(() =&gt; { $('pre code').each((i, block) =&gt; { hljs.highlightBlock(block); });}); Code Formatting Tables and alignment First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 Table Syntax Task list a bigger project first subtask follow up subtask final subtask a separate task Task List Syntax AbbreviationMarkup is based on php markdown extra definition, but without multiline support: *[HTML]: Hyper Text Markup Language*[W3C]: World Wide Web ConsortiumThe HTML specificationis maintained by the W3C. FootnoteHere is a footnote reference,[^1] and another.[^longnote] [^1]: Here is the footnote. [^longnote]: Here’s one with multiple blocks. Subsequent paragraphs are indented to show that theybelong to the previous footnote. Here is an inline note.^[Inlines notes are easier to write, sinceyou don’t have to pick an identifier and move down to type thenote.] Footnote Syntax Mathematical formula $y = x^2$Inline math: $\\dfrac{ \\tfrac{1}{2}[1-(\\tfrac{1}{2})^n] }{ 1-\\tfrac{1}{2} } = s_n$. Math block: 1234567891011121314\\oint_C x^3\\, dx + 4y^2\\, dy2 = \\left( \\frac{\\left(3-x\\right) \\times 2}{3-x} \\right)\\sum_{m=1}^\\infty\\sum_{n=1}^\\infty\\frac{m^2\\,n} {3^m\\left(m\\,3^n+n\\,3^m\\right)}\\phi_n(\\kappa) = \\frac{1}{4\\pi^2\\kappa^2} \\int_0^\\infty \\frac{\\sin(\\kappa R)}{\\kappa R} \\frac{\\partial}{\\partial R} \\left[R^2\\frac{\\partial D_n(R)}{\\partial R}\\right]\\,dR Mathematical Formula Syntax AsciiMathInline AsciiMath: @(1/2[1-(1/2)^n])/(1-(1/2))=s_n@ 12345oint_Cx^3 dx+4y^2 dy2=(((3-x)xx2)/(3-x))sum_(m=1)^oosum_(n=1)^oo(m^2 n)/(3^m(m3^n+n3^m) 1234phi_n(kappa) = 1/(4pi^2 kappa^2) int_0^oo (sin(kappa R))/(kappa R) del/(del R)[R^2 (del D_n (R))/(del R)] del R AsciiMath Documentation mermaid chartsFlowchart123456graph TDA[Christmas] --&gt;|Get money| B(Go shopping)B --&gt; C{Let me think}C --&gt;|One| D[Laptop]C --&gt;|Two| E[iPhone]C --&gt;|Three| F[Car] Flowchart Syntax ::: warningAdding many flowcharts will slow down the editor.::: Sequence diagram12345sequenceDiagramloop every day Alice-&gt;&gt;John: Hello John, how are you? John--&gt;&gt;Alice: Great!end Sequence Diagram Syntax ::: warningAdding many sequence diagrams will slow down the editor.::: Gantt diagram123456789101112131415161718192021222324252627ganttdateFormat YYYY-MM-DDtitle Adding GANTT diagram to mermaidsection A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5dsection Critical tasksCompleted task in the critical line :crit, done, 2014-01-06,24hImplement parser and jison :crit, done, after des1, 2dCreate tests for parser :crit, active, 3dFuture task in critical line :crit, 5dCreate tests for renderer :2dAdd to mermaid :1dsection DocumentationDescribe gantt syntax :active, a1, after des1, 3dAdd gantt diagram to demo page :after a1 , 20hAdd another diagram to demo page :doc1, after a1 , 48hsection Last sectionDescribe gantt syntax :after doc1, 3dAdd gantt diagram to demo page : 20hAdd another diagram to demo page : 48h Gantt Diagram Syntax ::: warningAdding many gantt diagrams will slow down the editor.::: Class diagram1234567891011121314classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label Class diagram is powered by mermaid. ::: warningAdding many class diagrams will slow down the editor.::: Custom ContainerMarkup is similar to fenced code blocks. Valid container types are success, info, warning and danger. ::: infoYou have new mail.::: ::: dangerStaying up all night is bad for health.::: Definition listTerm 1 ~ Definition 1 Term 2 ~ Definition 2a ~ Definition 2b Definition List Syntax HTMLIf you find the markdown syntax too limited, you can try some HTML: ChartsDocumentation for charts Line Chart1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ &quot;type&quot;: &quot;line&quot;, &quot;data&quot;: { &quot;labels&quot;: [ &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot; ], &quot;datasets&quot;: [ { &quot;label&quot;: &quot;# of bugs&quot;, &quot;fill&quot;: false, &quot;lineTension&quot;: 0.1, &quot;backgroundColor&quot;: &quot;rgba(75,192,192,0.4)&quot;, &quot;borderColor&quot;: &quot;rgba(75,192,192,1)&quot;, &quot;borderCapStyle&quot;: &quot;butt&quot;, &quot;borderDash&quot;: [], &quot;borderDashOffset&quot;: 0, &quot;borderJoinStyle&quot;: &quot;miter&quot;, &quot;pointBorderColor&quot;: &quot;rgba(75,192,192,1)&quot;, &quot;pointBackgroundColor&quot;: &quot;#fff&quot;, &quot;pointBorderWidth&quot;: 1, &quot;pointHoverRadius&quot;: 5, &quot;pointHoverBackgroundColor&quot;: &quot;rgba(75,192,192,1)&quot;, &quot;pointHoverBorderColor&quot;: &quot;rgba(220,220,220,1)&quot;, &quot;pointHoverBorderWidth&quot;: 2, &quot;pointRadius&quot;: 1, &quot;pointHitRadius&quot;: 10, &quot;data&quot;: [ 65, 59, 80, 81, 56, 55, 40 ], &quot;spanGaps&quot;: false } ] }, &quot;options&quot;: {}} Documentation for Line Chart Bar Chart1234567891011121314151617181920212223242526272829303132333435363738394041424344{ &quot;type&quot;: &quot;bar&quot;, &quot;data&quot;: { &quot;labels&quot;: [ &quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Purple&quot;, &quot;Orange&quot; ], &quot;datasets&quot;: [ { &quot;label&quot;: &quot;# of Votes&quot;, &quot;data&quot;: [ 12, 19, 3, 5, 2, 3 ], &quot;backgroundColor&quot;: [ &quot;rgba(255, 99, 132, 0.2)&quot;, &quot;rgba(54, 162, 235, 0.2)&quot;, &quot;rgba(255, 206, 86, 0.2)&quot;, &quot;rgba(75, 192, 192, 0.2)&quot;, &quot;rgba(153, 102, 255, 0.2)&quot;, &quot;rgba(255, 159, 64, 0.2)&quot; ], &quot;borderColor&quot;: [ &quot;rgba(255,99,132,1)&quot;, &quot;rgba(54, 162, 235, 1)&quot;, &quot;rgba(255, 206, 86, 1)&quot;, &quot;rgba(75, 192, 192, 1)&quot;, &quot;rgba(153, 102, 255, 1)&quot;, &quot;rgba(255, 159, 64, 1)&quot; ], &quot;borderWidth&quot;: 1 } ] }, &quot;options&quot;: {}} Documentation for Bar Chart Radar Chart1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253{ &quot;type&quot;: &quot;radar&quot;, &quot;data&quot;: { &quot;labels&quot;: [ &quot;Eating&quot;, &quot;Drinking&quot;, &quot;Sleeping&quot;, &quot;Designing&quot;, &quot;Coding&quot;, &quot;Cycling&quot;, &quot;Running&quot; ], &quot;datasets&quot;: [ { &quot;label&quot;: &quot;My First dataset&quot;, &quot;backgroundColor&quot;: &quot;rgba(179,181,198,0.2)&quot;, &quot;borderColor&quot;: &quot;rgba(179,181,198,1)&quot;, &quot;pointBackgroundColor&quot;: &quot;rgba(179,181,198,1)&quot;, &quot;pointBorderColor&quot;: &quot;#fff&quot;, &quot;pointHoverBackgroundColor&quot;: &quot;#fff&quot;, &quot;pointHoverBorderColor&quot;: &quot;rgba(179,181,198,1)&quot;, &quot;data&quot;: [ 65, 59, 90, 81, 56, 55, 40 ] }, { &quot;label&quot;: &quot;My Second dataset&quot;, &quot;backgroundColor&quot;: &quot;rgba(255,99,132,0.2)&quot;, &quot;borderColor&quot;: &quot;rgba(255,99,132,1)&quot;, &quot;pointBackgroundColor&quot;: &quot;rgba(255,99,132,1)&quot;, &quot;pointBorderColor&quot;: &quot;#fff&quot;, &quot;pointHoverBackgroundColor&quot;: &quot;#fff&quot;, &quot;pointHoverBorderColor&quot;: &quot;rgba(255,99,132,1)&quot;, &quot;data&quot;: [ 28, 48, 40, 19, 96, 27, 100 ] } ] }, &quot;options&quot;: {}} Documentation for Radar Chart Polar Area Chart1234567891011121314151617181920212223242526272829303132{ &quot;type&quot;: &quot;polarArea&quot;, &quot;data&quot;: { &quot;datasets&quot;: [ { &quot;data&quot;: [ 11, 16, 7, 3, 14 ], &quot;backgroundColor&quot;: [ &quot;#FF6384&quot;, &quot;#4BC0C0&quot;, &quot;#FFCE56&quot;, &quot;#E7E9ED&quot;, &quot;#36A2EB&quot; ], &quot;label&quot;: &quot;My dataset&quot; } ], &quot;labels&quot;: [ &quot;Red&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Grey&quot;, &quot;Blue&quot; ] }, &quot;options&quot;: {}} Documentation for Polar Area Chart Pie Chart123456789101112131415161718192021222324252627282930{ &quot;type&quot;: &quot;pie&quot;, &quot;data&quot;: { &quot;labels&quot;: [ &quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot; ], &quot;datasets&quot;: [ { &quot;data&quot;: [ 300, 50, 100 ], &quot;backgroundColor&quot;: [ &quot;#FF6384&quot;, &quot;#36A2EB&quot;, &quot;#FFCE56&quot; ], &quot;hoverBackgroundColor&quot;: [ &quot;#FF6384&quot;, &quot;#36A2EB&quot;, &quot;#FFCE56&quot; ] } ] }, &quot;options&quot;: {}} Documentation for Pie Chart Doughnut Chart123456789101112131415161718192021222324252627282930{ &quot;type&quot;: &quot;doughnut&quot;, &quot;data&quot;: { &quot;labels&quot;: [ &quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot; ], &quot;datasets&quot;: [ { &quot;data&quot;: [ 300, 50, 100 ], &quot;backgroundColor&quot;: [ &quot;#FF6384&quot;, &quot;#36A2EB&quot;, &quot;#FFCE56&quot; ], &quot;hoverBackgroundColor&quot;: [ &quot;#FF6384&quot;, &quot;#36A2EB&quot;, &quot;#FFCE56&quot; ] } ] }, &quot;options&quot;: {}} Documentation for Doughnut Chart Bubble Chart12345678910111213141516171819202122232425{ &quot;type&quot;: &quot;bubble&quot;, &quot;data&quot;: { &quot;datasets&quot;: [ { &quot;label&quot;: &quot;First Dataset&quot;, &quot;data&quot;: [ { &quot;x&quot;: 20, &quot;y&quot;: 30, &quot;r&quot;: 15 }, { &quot;x&quot;: 40, &quot;y&quot;: 10, &quot;r&quot;: 10 } ], &quot;backgroundColor&quot;: &quot;#FF6384&quot;, &quot;hoverBackgroundColor&quot;: &quot;#FF6384&quot; } ] }, &quot;options&quot;: {}} Documentation for Bubble Chart","link":"/2019-09-20-Markdown-Plus.html"},{"title":"printf 函数重定向到UART串口输出","text":"快捷注释所有 printf() 调用语句123456789101112131415161718192021#if 1 #define PRINTF printf#else #define PRINTF(...)#endif/* 或者分模块注释printf，方便调试，例如ADC和TIM1模块内 * 进行调试信息打印时，可分别调用各自的printf宏定义别名， * 这么做可以在程序调试期间方便对某一模块的调试信息功能启用和关闭 */#if 1 #define ADC_PRINTF printf#else #define ADC_PRINTF(...)#endif#if 1 #define TIM1_PRINTF printf#else #define TIM1_PRINTF(...)#endif printf 动态打印已知长度字符串12345/* 动态打印已知长度的字符串 */printf(\"%.*s\\r\\n\", length, str);/* 动态打印已知长度的字符串，totalLen指最终打印字符串的长度，strLen指打印str的多少个字符 */printf(\"%*.*s\\r\\n\", totalLen, strLen, str); Keil MDK, GCC ( True Studio / NXP S32 Design Studio / … )123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#ifdef __GNUC__/* 若需打印浮点数 则需要在 * 工程属性-&gt;C/C++ Build-&gt;Settings-&gt;C Linker-&gt;Miscellaneous-&gt;Other options中添加 -u _printf_float * 以使能浮点打印功能，此外，使能浮点打印功能，编译后会明显增加RAM和FLASH占用 *//* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf set to 'Yes') calls __io_putchar() */#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)#else#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)#ifndef __MICROLIB/* 加入以下代码，支持printf函数，而不需要选择use MicroLIB */#pragma import(__use_no_semihosting)/* 标准库需要的支持函数 */struct __FILE { int handle;};/* FILE 定义在 stdio.h */FILE __stdout;/* 定义_sys_exit()以避免使用半主机模式 */void _sys_exit(int x){ x = x;}#endif#endif /* __GNUC__ *///#define USE_REG_FOR_PRINTFPUTCHAR_PROTOTYPE {#if defined(USE_REG_FOR_PRINTF) /* 寄存器方式 */ /* MM32 */// while ((UART2-&gt;CSR &amp; UART_FLAG_TXEMPTY) == RESET);// UART2-&gt;TDR = (ch &amp; (uint16_t)0x00FF); /* STM32 不同型号的寄存器及相关FLAG定义有所不同，按需选择 */#if 0 while ((USART2-&gt;SR &amp; USART_FLAG_TXE) == RESET); USART2-&gt;DR = (uint8_t)ch; while ((USART2-&gt;SR &amp; USART_FLAG_TC) == RESET);#else while ((USART2-&gt;ISR &amp; USART_ISR_TXE) == RESET); USART2-&gt;TDR = (uint8_t)ch; while ((USART2-&gt;ISR &amp; USART_ISR_TC) == RESET);#endif#else#if defined(USE_STDPERIPH_DRIVER) /* SPL标准库方式 */ while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET); USART_SendData(USART2, (uint8_t)ch); while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);#endif#if defined(USE_FULL_LL_DRIVER) /* LL库方式 */ while (LL_USART_IsActiveFlag_TXE(USART2) == RESET); LL_USART_TransmitData8(USART2, ch); while (LL_USART_IsActiveFlag_TC(USART2) == RESET);#endif /* USE_FULL_LL_DRIVER */#if defined(USE_HAL_DRIVER) /* HAL库方式 */ HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY);#endif /* USE_HAL_DRIVER */#endif /* USE_REG_FOR_PRINTF */ return ch;} 自定义一个可传不定量参数的printf函数123456789101112void SCI_printf(const char *format, ...){ char TX_Buffer[256]; va_list args; va_start(args, format);// va_starttop(args, format); vsprintf(TX_Buffer, format, args); va_end(args); LPUART_DRV_SendDataBlocking(INST_LPUART1, (const uint8_t *)TX_Buffer, strlen((const char *)TX_Buffer), 50U);} Segger J-Link RTT123456789/* SEGGER J-Link RTT Viewer PC客户端快捷方式参数设置 *//* 长参数: */ -device STM32F031K6 -connection usb -interface swd -speed 4000 -autoconnect/* 短参数: */ -d STM32F031K6 -ct usb -if swd -s 4000 -a/* 建议使用短参数，长参数可能不生效。 *//* 示例，如下设置 \"目标\" 项: */\"C:\\Program Files (x86)\\SEGGER\\JLink_V644g\\JLinkRTTViewer.exe\" -d STM32F031K6 -ct usb -if swd -s 4000 -a 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*RTT软件包一般都在Segger J-Link驱动的安装目录下：C:\\Program Files (x86)\\SEGGER\\JLink_V644g\\Samples\\RTT将压缩包内最关键的RTT目录内的几个源文件添加到工程中，并在SEGGER_RTT_Conf.h 内配置相关Buffer的大小即可开始使用，若需重定向 printf() 函数，则需要根据 IDE 所使用的工具链，添加 Syscalls 文件夹内的对应源文件，进行重定向。*/#if 1 #define PRINTF SEGGER_RTT_printf#else #define PRINTF(...)#endifSEGGER_RTT_Init();SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL);/* TODO: J-Link RTT 使用示例 */PRINTF(0, \"%sCounter: %s%s%u%s \", RTT_CTRL_RESET, RTT_CTRL_BG_BRIGHT_RED, RTT_CTRL_TEXT_BRIGHT_WHITE, cnt++, RTT_CTRL_RESET);SEGGER_RTT_WriteString(0, \"SEGGER Real-Time-Terminal Sample\\r\\n\");SEGGER_RTT_WriteString(0, \"###### Testing SEGGER_printf() ######\\r\\n\");PRINTF(0, \"printf Test: %%s, \\\"RTT\\\" : %s.\\r\\n\", \"RTT\");PRINTF(0, \"%sprintf Test: %s%%u, 12345 : %u.%s\\r\\n\", RTT_CTRL_TEXT_WHITE, RTT_CTRL_TEXT_BRIGHT_RED, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%+u, 12345 : %+u.%s\\r\\n\", RTT_CTRL_TEXT_BRIGHT_WHITE, RTT_CTRL_TEXT_BRIGHT_GREEN, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%.3u, 12345 : %.3u.%s\\r\\n\", RTT_CTRL_TEXT_WHITE, RTT_CTRL_TEXT_BRIGHT_YELLOW, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%.6u, 12345 : %.6u.%s\\r\\n\", RTT_CTRL_TEXT_BRIGHT_WHITE, RTT_CTRL_TEXT_BRIGHT_BLUE, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%6.3u, 12345 : %6.3u.%s\\r\\n\", RTT_CTRL_TEXT_WHITE, RTT_CTRL_TEXT_BRIGHT_MAGENTA, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%8.6u, 12345 : %8.6u.%s\\r\\n\", RTT_CTRL_TEXT_BRIGHT_WHITE, RTT_CTRL_TEXT_BRIGHT_CYAN, 12345, RTT_CTRL_RESET);PRINTF(0, \"%sprintf Test: %s%%08u, 12345 : %08u.%s\\r\\n\", RTT_CTRL_TEXT_WHITE, RTT_CTRL_TEXT_BRIGHT_WHITE, 12345, RTT_CTRL_RESET);PRINTF(0, \"printf Test: %%p, &amp;_Cnt : %p.\\r\\n\", &amp;_Cnt);SEGGER_RTT_WriteString(0, RTT_CTRL_RESET\"Red: \" \\ RTT_CTRL_TEXT_BRIGHT_RED\"This text is red. \" \\ RTT_CTRL_TEXT_BLACK\"\" \\ RTT_CTRL_BG_BRIGHT_RED\"This background is red. \" \\ RTT_CTRL_RESET\"Normal text again.\\r\\n\");SEGGER_RTT_WriteString(0, \"###### SEGGER_printf() Tests done. ######\\r\\n\\r\\n\");/* 在Terminal 1输出信息 */SEGGER_RTT_TerminalOut(1, RTT_CTRL_TEXT_BRIGHT_RED\"Counter overflow!\\r\\n\"RTT_CTRL_RESET);/* 清空 J-Link RTT Viewer 的输出显示 *///SEGGER_RTT_WriteString(0, RTT_CTRL_CLEAR);","link":"/2019-09-20-printf-函数重定向到UART串口输出.html"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Standard","slug":"Standard","link":"/tags/Standard/"},{"name":"Coding Style","slug":"Coding-Style","link":"/tags/Coding-Style/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"Code Composer Studio","slug":"Code-Composer-Studio","link":"/tags/Code-Composer-Studio/"},{"name":"Static Lib","slug":"Static-Lib","link":"/tags/Static-Lib/"},{"name":"Astyle","slug":"Astyle","link":"/tags/Astyle/"},{"name":"Hello","slug":"Hello","link":"/tags/Hello/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Markdown Plus","slug":"Markdown-Plus","link":"/tags/Markdown-Plus/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"UART","slug":"UART","link":"/tags/UART/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"},{"name":"IDE","slug":"IDE","link":"/categories/IDE/"},{"name":"Standard","slug":"C/Standard","link":"/categories/C/Standard/"},{"name":"Code Composer Studio","slug":"IDE/Code-Composer-Studio","link":"/categories/IDE/Code-Composer-Studio/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Debug","slug":"Debug","link":"/categories/Debug/"},{"name":"STM32","slug":"Debug/STM32","link":"/categories/Debug/STM32/"}]}